/** ScriptOpenGL.cpp by Blue Cat Audio (www.bluecataudio.com)
*
*/

#include "ScriptOpenGL.h"
#include <assert.h> // assert()

// openGL
#ifdef _WIN32
#include <windows.h>
#define asGLFunctionCall asCALL_STDCALL
#include <gl/gl.h>
#else
#define asGLFunctionCall asCALL_CDECL
#define GL_EXT_vertex_array 1
#include <OpenGL/gl.h>
#include <OpenGL/glext.h>
#endif


GLenum kGL_VERSION_1_1=GL_VERSION_1_1;
GLenum kGL_ACCUM=GL_ACCUM;
GLenum kGL_LOAD=GL_LOAD;
GLenum kGL_RETURN=GL_RETURN;
GLenum kGL_MULT=GL_MULT;
GLenum kGL_ADD=GL_ADD;
GLenum kGL_NEVER=GL_NEVER;
GLenum kGL_LESS=GL_LESS;
GLenum kGL_EQUAL=GL_EQUAL;
GLenum kGL_LEQUAL=GL_LEQUAL;
GLenum kGL_GREATER=GL_GREATER;
GLenum kGL_NOTEQUAL=GL_NOTEQUAL;
GLenum kGL_GEQUAL=GL_GEQUAL;
GLenum kGL_ALWAYS=GL_ALWAYS;
GLbitfield kGL_CURRENT_BIT=GL_CURRENT_BIT;
GLbitfield kGL_POINT_BIT=GL_POINT_BIT;
GLbitfield kGL_LINE_BIT=GL_LINE_BIT;
GLbitfield kGL_POLYGON_BIT=GL_POLYGON_BIT;
GLbitfield kGL_POLYGON_STIPPLE_BIT=GL_POLYGON_STIPPLE_BIT;
GLbitfield kGL_PIXEL_MODE_BIT=GL_PIXEL_MODE_BIT;
GLbitfield kGL_LIGHTING_BIT=GL_LIGHTING_BIT;
GLbitfield kGL_FOG_BIT=GL_FOG_BIT;
GLbitfield kGL_DEPTH_BUFFER_BIT=GL_DEPTH_BUFFER_BIT;
GLbitfield kGL_ACCUM_BUFFER_BIT=GL_ACCUM_BUFFER_BIT;
GLbitfield kGL_STENCIL_BUFFER_BIT=GL_STENCIL_BUFFER_BIT;
GLbitfield kGL_VIEWPORT_BIT=GL_VIEWPORT_BIT;
GLbitfield kGL_TRANSFORM_BIT=GL_TRANSFORM_BIT;
GLbitfield kGL_ENABLE_BIT=GL_ENABLE_BIT;
GLbitfield kGL_COLOR_BUFFER_BIT=GL_COLOR_BUFFER_BIT;
GLbitfield kGL_HINT_BIT=GL_HINT_BIT;
GLbitfield kGL_EVAL_BIT=GL_EVAL_BIT;
GLbitfield kGL_LIST_BIT=GL_LIST_BIT;
GLbitfield kGL_TEXTURE_BIT=GL_TEXTURE_BIT;
GLbitfield kGL_SCISSOR_BIT=GL_SCISSOR_BIT;
GLenum kGL_ALL_ATTRIB_BITS=GL_ALL_ATTRIB_BITS;
GLenum kGL_POINTS=GL_POINTS;
GLenum kGL_LINES=GL_LINES;
GLenum kGL_LINE_LOOP=GL_LINE_LOOP;
GLenum kGL_LINE_STRIP=GL_LINE_STRIP;
GLenum kGL_TRIANGLES=GL_TRIANGLES;
GLenum kGL_TRIANGLE_STRIP=GL_TRIANGLE_STRIP;
GLenum kGL_TRIANGLE_FAN=GL_TRIANGLE_FAN;
GLenum kGL_QUADS=GL_QUADS;
GLenum kGL_QUAD_STRIP=GL_QUAD_STRIP;
GLenum kGL_POLYGON=GL_POLYGON;
GLenum kGL_ZERO=GL_ZERO;
GLenum kGL_ONE=GL_ONE;
GLenum kGL_SRC_COLOR=GL_SRC_COLOR;
GLenum kGL_ONE_MINUS_SRC_COLOR=GL_ONE_MINUS_SRC_COLOR;
GLenum kGL_SRC_ALPHA=GL_SRC_ALPHA;
GLenum kGL_ONE_MINUS_SRC_ALPHA=GL_ONE_MINUS_SRC_ALPHA;
GLenum kGL_DST_ALPHA=GL_DST_ALPHA;
GLenum kGL_ONE_MINUS_DST_ALPHA=GL_ONE_MINUS_DST_ALPHA;
GLenum kGL_DST_COLOR=GL_DST_COLOR;
GLenum kGL_ONE_MINUS_DST_COLOR=GL_ONE_MINUS_DST_COLOR;
GLenum kGL_SRC_ALPHA_SATURATE=GL_SRC_ALPHA_SATURATE;
GLenum kGL_TRUE=GL_TRUE;
GLenum kGL_FALSE=GL_FALSE;
GLenum kGL_CLIP_PLANE0=GL_CLIP_PLANE0;
GLenum kGL_CLIP_PLANE1=GL_CLIP_PLANE1;
GLenum kGL_CLIP_PLANE2=GL_CLIP_PLANE2;
GLenum kGL_CLIP_PLANE3=GL_CLIP_PLANE3;
GLenum kGL_CLIP_PLANE4=GL_CLIP_PLANE4;
GLenum kGL_CLIP_PLANE5=GL_CLIP_PLANE5;
GLenum kGL_BYTE=GL_BYTE;
GLenum kGL_UNSIGNED_BYTE=GL_UNSIGNED_BYTE;
GLenum kGL_SHORT=GL_SHORT;
GLenum kGL_UNSIGNED_SHORT=GL_UNSIGNED_SHORT;
GLenum kGL_INT=GL_INT;
GLenum kGL_UNSIGNED_INT=GL_UNSIGNED_INT;
GLenum kGL_FLOAT=GL_FLOAT;
GLenum kGL_2_BYTES=GL_2_BYTES;
GLenum kGL_3_BYTES=GL_3_BYTES;
GLenum kGL_4_BYTES=GL_4_BYTES;
GLenum kGL_DOUBLE=GL_DOUBLE;
GLenum kGL_NONE=GL_NONE;
GLenum kGL_FRONT_LEFT=GL_FRONT_LEFT;
GLenum kGL_FRONT_RIGHT=GL_FRONT_RIGHT;
GLenum kGL_BACK_LEFT=GL_BACK_LEFT;
GLenum kGL_BACK_RIGHT=GL_BACK_RIGHT;
GLenum kGL_FRONT=GL_FRONT;
GLenum kGL_BACK=GL_BACK;
GLenum kGL_LEFT=GL_LEFT;
GLenum kGL_RIGHT=GL_RIGHT;
GLenum kGL_FRONT_AND_BACK=GL_FRONT_AND_BACK;
GLenum kGL_AUX0=GL_AUX0;
GLenum kGL_AUX1=GL_AUX1;
GLenum kGL_AUX2=GL_AUX2;
GLenum kGL_AUX3=GL_AUX3;
GLenum kGL_NO_ERROR=GL_NO_ERROR;
GLenum kGL_INVALID_ENUM=GL_INVALID_ENUM;
GLenum kGL_INVALID_VALUE=GL_INVALID_VALUE;
GLenum kGL_INVALID_OPERATION=GL_INVALID_OPERATION;
GLenum kGL_STACK_OVERFLOW=GL_STACK_OVERFLOW;
GLenum kGL_STACK_UNDERFLOW=GL_STACK_UNDERFLOW;
GLenum kGL_OUT_OF_MEMORY=GL_OUT_OF_MEMORY;
GLenum kGL_2D=GL_2D;
GLenum kGL_3D=GL_3D;
GLenum kGL_3D_COLOR=GL_3D_COLOR;
GLenum kGL_3D_COLOR_TEXTURE=GL_3D_COLOR_TEXTURE;
GLenum kGL_4D_COLOR_TEXTURE=GL_4D_COLOR_TEXTURE;
GLenum kGL_PASS_THROUGH_TOKEN=GL_PASS_THROUGH_TOKEN;
GLenum kGL_POINT_TOKEN=GL_POINT_TOKEN;
GLenum kGL_LINE_TOKEN=GL_LINE_TOKEN;
GLenum kGL_POLYGON_TOKEN=GL_POLYGON_TOKEN;
GLenum kGL_BITMAP_TOKEN=GL_BITMAP_TOKEN;
GLenum kGL_DRAW_PIXEL_TOKEN=GL_DRAW_PIXEL_TOKEN;
GLenum kGL_COPY_PIXEL_TOKEN=GL_COPY_PIXEL_TOKEN;
GLenum kGL_LINE_RESET_TOKEN=GL_LINE_RESET_TOKEN;
GLenum kGL_EXP=GL_EXP;
GLenum kGL_EXP2=GL_EXP2;
GLenum kGL_CW=GL_CW;
GLenum kGL_CCW=GL_CCW;
GLenum kGL_COEFF=GL_COEFF;
GLenum kGL_ORDER=GL_ORDER;
GLenum kGL_DOMAIN=GL_DOMAIN;
GLenum kGL_CURRENT_COLOR=GL_CURRENT_COLOR;
GLenum kGL_CURRENT_INDEX=GL_CURRENT_INDEX;
GLenum kGL_CURRENT_NORMAL=GL_CURRENT_NORMAL;
GLenum kGL_CURRENT_TEXTURE_COORDS=GL_CURRENT_TEXTURE_COORDS;
GLenum kGL_CURRENT_RASTER_COLOR=GL_CURRENT_RASTER_COLOR;
GLenum kGL_CURRENT_RASTER_INDEX=GL_CURRENT_RASTER_INDEX;
GLenum kGL_CURRENT_RASTER_TEXTURE_COORDS=GL_CURRENT_RASTER_TEXTURE_COORDS;
GLenum kGL_CURRENT_RASTER_POSITION=GL_CURRENT_RASTER_POSITION;
GLenum kGL_CURRENT_RASTER_POSITION_VALID=GL_CURRENT_RASTER_POSITION_VALID;
GLenum kGL_CURRENT_RASTER_DISTANCE=GL_CURRENT_RASTER_DISTANCE;
GLenum kGL_POINT_SMOOTH=GL_POINT_SMOOTH;
GLenum kGL_POINT_SIZE=GL_POINT_SIZE;
GLenum kGL_POINT_SIZE_RANGE=GL_POINT_SIZE_RANGE;
GLenum kGL_POINT_SIZE_GRANULARITY=GL_POINT_SIZE_GRANULARITY;
GLenum kGL_LINE_SMOOTH=GL_LINE_SMOOTH;
GLenum kGL_LINE_WIDTH=GL_LINE_WIDTH;
GLenum kGL_LINE_WIDTH_RANGE=GL_LINE_WIDTH_RANGE;
GLenum kGL_LINE_WIDTH_GRANULARITY=GL_LINE_WIDTH_GRANULARITY;
GLenum kGL_LINE_STIPPLE=GL_LINE_STIPPLE;
GLenum kGL_LINE_STIPPLE_PATTERN=GL_LINE_STIPPLE_PATTERN;
GLenum kGL_LINE_STIPPLE_REPEAT=GL_LINE_STIPPLE_REPEAT;
GLenum kGL_LIST_MODE=GL_LIST_MODE;
GLenum kGL_MAX_LIST_NESTING=GL_MAX_LIST_NESTING;
GLenum kGL_LIST_BASE=GL_LIST_BASE;
GLenum kGL_LIST_INDEX=GL_LIST_INDEX;
GLenum kGL_POLYGON_MODE=GL_POLYGON_MODE;
GLenum kGL_POLYGON_SMOOTH=GL_POLYGON_SMOOTH;
GLenum kGL_POLYGON_STIPPLE=GL_POLYGON_STIPPLE;
GLenum kGL_EDGE_FLAG=GL_EDGE_FLAG;
GLenum kGL_CULL_FACE=GL_CULL_FACE;
GLenum kGL_CULL_FACE_MODE=GL_CULL_FACE_MODE;
GLenum kGL_FRONT_FACE=GL_FRONT_FACE;
GLenum kGL_LIGHTING=GL_LIGHTING;
GLenum kGL_LIGHT_MODEL_LOCAL_VIEWER=GL_LIGHT_MODEL_LOCAL_VIEWER;
GLenum kGL_LIGHT_MODEL_TWO_SIDE=GL_LIGHT_MODEL_TWO_SIDE;
GLenum kGL_LIGHT_MODEL_AMBIENT=GL_LIGHT_MODEL_AMBIENT;
GLenum kGL_SHADE_MODEL=GL_SHADE_MODEL;
GLenum kGL_COLOR_MATERIAL_FACE=GL_COLOR_MATERIAL_FACE;
GLenum kGL_COLOR_MATERIAL_PARAMETER=GL_COLOR_MATERIAL_PARAMETER;
GLenum kGL_COLOR_MATERIAL=GL_COLOR_MATERIAL;
GLenum kGL_FOG=GL_FOG;
GLenum kGL_FOG_INDEX=GL_FOG_INDEX;
GLenum kGL_FOG_DENSITY=GL_FOG_DENSITY;
GLenum kGL_FOG_START=GL_FOG_START;
GLenum kGL_FOG_END=GL_FOG_END;
GLenum kGL_FOG_MODE=GL_FOG_MODE;
GLenum kGL_FOG_COLOR=GL_FOG_COLOR;
GLenum kGL_DEPTH_RANGE=GL_DEPTH_RANGE;
GLenum kGL_DEPTH_TEST=GL_DEPTH_TEST;
GLenum kGL_DEPTH_WRITEMASK=GL_DEPTH_WRITEMASK;
GLenum kGL_DEPTH_CLEAR_VALUE=GL_DEPTH_CLEAR_VALUE;
GLenum kGL_DEPTH_FUNC=GL_DEPTH_FUNC;
GLenum kGL_ACCUM_CLEAR_VALUE=GL_ACCUM_CLEAR_VALUE;
GLenum kGL_STENCIL_TEST=GL_STENCIL_TEST;
GLenum kGL_STENCIL_CLEAR_VALUE=GL_STENCIL_CLEAR_VALUE;
GLenum kGL_STENCIL_FUNC=GL_STENCIL_FUNC;
GLenum kGL_STENCIL_VALUE_MASK=GL_STENCIL_VALUE_MASK;
GLenum kGL_STENCIL_FAIL=GL_STENCIL_FAIL;
GLenum kGL_STENCIL_PASS_DEPTH_FAIL=GL_STENCIL_PASS_DEPTH_FAIL;
GLenum kGL_STENCIL_PASS_DEPTH_PASS=GL_STENCIL_PASS_DEPTH_PASS;
GLenum kGL_STENCIL_REF=GL_STENCIL_REF;
GLenum kGL_STENCIL_WRITEMASK=GL_STENCIL_WRITEMASK;
GLenum kGL_MATRIX_MODE=GL_MATRIX_MODE;
GLenum kGL_NORMALIZE=GL_NORMALIZE;
GLenum kGL_VIEWPORT=GL_VIEWPORT;
GLenum kGL_MODELVIEW_STACK_DEPTH=GL_MODELVIEW_STACK_DEPTH;
GLenum kGL_PROJECTION_STACK_DEPTH=GL_PROJECTION_STACK_DEPTH;
GLenum kGL_TEXTURE_STACK_DEPTH=GL_TEXTURE_STACK_DEPTH;
GLenum kGL_MODELVIEW_MATRIX=GL_MODELVIEW_MATRIX;
GLenum kGL_PROJECTION_MATRIX=GL_PROJECTION_MATRIX;
GLenum kGL_TEXTURE_MATRIX=GL_TEXTURE_MATRIX;
GLenum kGL_ATTRIB_STACK_DEPTH=GL_ATTRIB_STACK_DEPTH;
GLenum kGL_CLIENT_ATTRIB_STACK_DEPTH=GL_CLIENT_ATTRIB_STACK_DEPTH;
GLenum kGL_ALPHA_TEST=GL_ALPHA_TEST;
GLenum kGL_ALPHA_TEST_FUNC=GL_ALPHA_TEST_FUNC;
GLenum kGL_ALPHA_TEST_REF=GL_ALPHA_TEST_REF;
GLenum kGL_DITHER=GL_DITHER;
GLenum kGL_BLEND_DST=GL_BLEND_DST;
GLenum kGL_BLEND_SRC=GL_BLEND_SRC;
GLenum kGL_BLEND=GL_BLEND;
GLenum kGL_LOGIC_OP_MODE=GL_LOGIC_OP_MODE;
GLenum kGL_INDEX_LOGIC_OP=GL_INDEX_LOGIC_OP;
GLenum kGL_COLOR_LOGIC_OP=GL_COLOR_LOGIC_OP;
GLenum kGL_AUX_BUFFERS=GL_AUX_BUFFERS;
GLenum kGL_DRAW_BUFFER=GL_DRAW_BUFFER;
GLenum kGL_READ_BUFFER=GL_READ_BUFFER;
GLenum kGL_SCISSOR_BOX=GL_SCISSOR_BOX;
GLenum kGL_SCISSOR_TEST=GL_SCISSOR_TEST;
GLenum kGL_INDEX_CLEAR_VALUE=GL_INDEX_CLEAR_VALUE;
GLenum kGL_INDEX_WRITEMASK=GL_INDEX_WRITEMASK;
GLenum kGL_COLOR_CLEAR_VALUE=GL_COLOR_CLEAR_VALUE;
GLenum kGL_COLOR_WRITEMASK=GL_COLOR_WRITEMASK;
GLenum kGL_INDEX_MODE=GL_INDEX_MODE;
GLenum kGL_RGBA_MODE=GL_RGBA_MODE;
GLenum kGL_DOUBLEBUFFER=GL_DOUBLEBUFFER;
GLenum kGL_STEREO=GL_STEREO;
GLenum kGL_RENDER_MODE=GL_RENDER_MODE;
GLenum kGL_PERSPECTIVE_CORRECTION_HINT=GL_PERSPECTIVE_CORRECTION_HINT;
GLenum kGL_POINT_SMOOTH_HINT=GL_POINT_SMOOTH_HINT;
GLenum kGL_LINE_SMOOTH_HINT=GL_LINE_SMOOTH_HINT;
GLenum kGL_POLYGON_SMOOTH_HINT=GL_POLYGON_SMOOTH_HINT;
GLenum kGL_FOG_HINT=GL_FOG_HINT;
GLenum kGL_TEXTURE_GEN_S=GL_TEXTURE_GEN_S;
GLenum kGL_TEXTURE_GEN_T=GL_TEXTURE_GEN_T;
GLenum kGL_TEXTURE_GEN_R=GL_TEXTURE_GEN_R;
GLenum kGL_TEXTURE_GEN_Q=GL_TEXTURE_GEN_Q;
GLenum kGL_PIXEL_MAP_I_TO_I=GL_PIXEL_MAP_I_TO_I;
GLenum kGL_PIXEL_MAP_S_TO_S=GL_PIXEL_MAP_S_TO_S;
GLenum kGL_PIXEL_MAP_I_TO_R=GL_PIXEL_MAP_I_TO_R;
GLenum kGL_PIXEL_MAP_I_TO_G=GL_PIXEL_MAP_I_TO_G;
GLenum kGL_PIXEL_MAP_I_TO_B=GL_PIXEL_MAP_I_TO_B;
GLenum kGL_PIXEL_MAP_I_TO_A=GL_PIXEL_MAP_I_TO_A;
GLenum kGL_PIXEL_MAP_R_TO_R=GL_PIXEL_MAP_R_TO_R;
GLenum kGL_PIXEL_MAP_G_TO_G=GL_PIXEL_MAP_G_TO_G;
GLenum kGL_PIXEL_MAP_B_TO_B=GL_PIXEL_MAP_B_TO_B;
GLenum kGL_PIXEL_MAP_A_TO_A=GL_PIXEL_MAP_A_TO_A;
GLenum kGL_PIXEL_MAP_I_TO_I_SIZE=GL_PIXEL_MAP_I_TO_I_SIZE;
GLenum kGL_PIXEL_MAP_S_TO_S_SIZE=GL_PIXEL_MAP_S_TO_S_SIZE;
GLenum kGL_PIXEL_MAP_I_TO_R_SIZE=GL_PIXEL_MAP_I_TO_R_SIZE;
GLenum kGL_PIXEL_MAP_I_TO_G_SIZE=GL_PIXEL_MAP_I_TO_G_SIZE;
GLenum kGL_PIXEL_MAP_I_TO_B_SIZE=GL_PIXEL_MAP_I_TO_B_SIZE;
GLenum kGL_PIXEL_MAP_I_TO_A_SIZE=GL_PIXEL_MAP_I_TO_A_SIZE;
GLenum kGL_PIXEL_MAP_R_TO_R_SIZE=GL_PIXEL_MAP_R_TO_R_SIZE;
GLenum kGL_PIXEL_MAP_G_TO_G_SIZE=GL_PIXEL_MAP_G_TO_G_SIZE;
GLenum kGL_PIXEL_MAP_B_TO_B_SIZE=GL_PIXEL_MAP_B_TO_B_SIZE;
GLenum kGL_PIXEL_MAP_A_TO_A_SIZE=GL_PIXEL_MAP_A_TO_A_SIZE;
GLenum kGL_UNPACK_SWAP_BYTES=GL_UNPACK_SWAP_BYTES;
GLenum kGL_UNPACK_LSB_FIRST=GL_UNPACK_LSB_FIRST;
GLenum kGL_UNPACK_ROW_LENGTH=GL_UNPACK_ROW_LENGTH;
GLenum kGL_UNPACK_SKIP_ROWS=GL_UNPACK_SKIP_ROWS;
GLenum kGL_UNPACK_SKIP_PIXELS=GL_UNPACK_SKIP_PIXELS;
GLenum kGL_UNPACK_ALIGNMENT=GL_UNPACK_ALIGNMENT;
GLenum kGL_PACK_SWAP_BYTES=GL_PACK_SWAP_BYTES;
GLenum kGL_PACK_LSB_FIRST=GL_PACK_LSB_FIRST;
GLenum kGL_PACK_ROW_LENGTH=GL_PACK_ROW_LENGTH;
GLenum kGL_PACK_SKIP_ROWS=GL_PACK_SKIP_ROWS;
GLenum kGL_PACK_SKIP_PIXELS=GL_PACK_SKIP_PIXELS;
GLenum kGL_PACK_ALIGNMENT=GL_PACK_ALIGNMENT;
GLenum kGL_MAP_COLOR=GL_MAP_COLOR;
GLenum kGL_MAP_STENCIL=GL_MAP_STENCIL;
GLenum kGL_INDEX_SHIFT=GL_INDEX_SHIFT;
GLenum kGL_INDEX_OFFSET=GL_INDEX_OFFSET;
GLenum kGL_RED_SCALE=GL_RED_SCALE;
GLenum kGL_RED_BIAS=GL_RED_BIAS;
GLenum kGL_ZOOM_X=GL_ZOOM_X;
GLenum kGL_ZOOM_Y=GL_ZOOM_Y;
GLenum kGL_GREEN_SCALE=GL_GREEN_SCALE;
GLenum kGL_GREEN_BIAS=GL_GREEN_BIAS;
GLenum kGL_BLUE_SCALE=GL_BLUE_SCALE;
GLenum kGL_BLUE_BIAS=GL_BLUE_BIAS;
GLenum kGL_ALPHA_SCALE=GL_ALPHA_SCALE;
GLenum kGL_ALPHA_BIAS=GL_ALPHA_BIAS;
GLenum kGL_DEPTH_SCALE=GL_DEPTH_SCALE;
GLenum kGL_DEPTH_BIAS=GL_DEPTH_BIAS;
GLenum kGL_MAX_EVAL_ORDER=GL_MAX_EVAL_ORDER;
GLenum kGL_MAX_LIGHTS=GL_MAX_LIGHTS;
GLenum kGL_MAX_CLIP_PLANES=GL_MAX_CLIP_PLANES;
GLenum kGL_MAX_TEXTURE_SIZE=GL_MAX_TEXTURE_SIZE;
GLenum kGL_MAX_PIXEL_MAP_TABLE=GL_MAX_PIXEL_MAP_TABLE;
GLenum kGL_MAX_ATTRIB_STACK_DEPTH=GL_MAX_ATTRIB_STACK_DEPTH;
GLenum kGL_MAX_MODELVIEW_STACK_DEPTH=GL_MAX_MODELVIEW_STACK_DEPTH;
GLenum kGL_MAX_NAME_STACK_DEPTH=GL_MAX_NAME_STACK_DEPTH;
GLenum kGL_MAX_PROJECTION_STACK_DEPTH=GL_MAX_PROJECTION_STACK_DEPTH;
GLenum kGL_MAX_TEXTURE_STACK_DEPTH=GL_MAX_TEXTURE_STACK_DEPTH;
GLenum kGL_MAX_VIEWPORT_DIMS=GL_MAX_VIEWPORT_DIMS;
GLenum kGL_MAX_CLIENT_ATTRIB_STACK_DEPTH=GL_MAX_CLIENT_ATTRIB_STACK_DEPTH;
GLenum kGL_SUBPIXEL_BITS=GL_SUBPIXEL_BITS;
GLenum kGL_INDEX_BITS=GL_INDEX_BITS;
GLenum kGL_RED_BITS=GL_RED_BITS;
GLenum kGL_GREEN_BITS=GL_GREEN_BITS;
GLenum kGL_BLUE_BITS=GL_BLUE_BITS;
GLenum kGL_ALPHA_BITS=GL_ALPHA_BITS;
GLenum kGL_DEPTH_BITS=GL_DEPTH_BITS;
GLenum kGL_STENCIL_BITS=GL_STENCIL_BITS;
GLenum kGL_ACCUM_RED_BITS=GL_ACCUM_RED_BITS;
GLenum kGL_ACCUM_GREEN_BITS=GL_ACCUM_GREEN_BITS;
GLenum kGL_ACCUM_BLUE_BITS=GL_ACCUM_BLUE_BITS;
GLenum kGL_ACCUM_ALPHA_BITS=GL_ACCUM_ALPHA_BITS;
GLenum kGL_NAME_STACK_DEPTH=GL_NAME_STACK_DEPTH;
GLenum kGL_AUTO_NORMAL=GL_AUTO_NORMAL;
GLenum kGL_MAP1_COLOR_4=GL_MAP1_COLOR_4;
GLenum kGL_MAP1_INDEX=GL_MAP1_INDEX;
GLenum kGL_MAP1_NORMAL=GL_MAP1_NORMAL;
GLenum kGL_MAP1_TEXTURE_COORD_1=GL_MAP1_TEXTURE_COORD_1;
GLenum kGL_MAP1_TEXTURE_COORD_2=GL_MAP1_TEXTURE_COORD_2;
GLenum kGL_MAP1_TEXTURE_COORD_3=GL_MAP1_TEXTURE_COORD_3;
GLenum kGL_MAP1_TEXTURE_COORD_4=GL_MAP1_TEXTURE_COORD_4;
GLenum kGL_MAP1_VERTEX_3=GL_MAP1_VERTEX_3;
GLenum kGL_MAP1_VERTEX_4=GL_MAP1_VERTEX_4;
GLenum kGL_MAP2_COLOR_4=GL_MAP2_COLOR_4;
GLenum kGL_MAP2_INDEX=GL_MAP2_INDEX;
GLenum kGL_MAP2_NORMAL=GL_MAP2_NORMAL;
GLenum kGL_MAP2_TEXTURE_COORD_1=GL_MAP2_TEXTURE_COORD_1;
GLenum kGL_MAP2_TEXTURE_COORD_2=GL_MAP2_TEXTURE_COORD_2;
GLenum kGL_MAP2_TEXTURE_COORD_3=GL_MAP2_TEXTURE_COORD_3;
GLenum kGL_MAP2_TEXTURE_COORD_4=GL_MAP2_TEXTURE_COORD_4;
GLenum kGL_MAP2_VERTEX_3=GL_MAP2_VERTEX_3;
GLenum kGL_MAP2_VERTEX_4=GL_MAP2_VERTEX_4;
GLenum kGL_MAP1_GRID_DOMAIN=GL_MAP1_GRID_DOMAIN;
GLenum kGL_MAP1_GRID_SEGMENTS=GL_MAP1_GRID_SEGMENTS;
GLenum kGL_MAP2_GRID_DOMAIN=GL_MAP2_GRID_DOMAIN;
GLenum kGL_MAP2_GRID_SEGMENTS=GL_MAP2_GRID_SEGMENTS;
GLenum kGL_TEXTURE_1D=GL_TEXTURE_1D;
GLenum kGL_TEXTURE_2D=GL_TEXTURE_2D;
GLenum kGL_FEEDBACK_BUFFER_POINTER=GL_FEEDBACK_BUFFER_POINTER;
GLenum kGL_FEEDBACK_BUFFER_SIZE=GL_FEEDBACK_BUFFER_SIZE;
GLenum kGL_FEEDBACK_BUFFER_TYPE=GL_FEEDBACK_BUFFER_TYPE;
GLenum kGL_SELECTION_BUFFER_POINTER=GL_SELECTION_BUFFER_POINTER;
GLenum kGL_SELECTION_BUFFER_SIZE=GL_SELECTION_BUFFER_SIZE;
GLenum kGL_TEXTURE_WIDTH=GL_TEXTURE_WIDTH;
GLenum kGL_TEXTURE_HEIGHT=GL_TEXTURE_HEIGHT;
GLenum kGL_TEXTURE_INTERNAL_FORMAT=GL_TEXTURE_INTERNAL_FORMAT;
GLenum kGL_TEXTURE_BORDER_COLOR=GL_TEXTURE_BORDER_COLOR;
GLenum kGL_TEXTURE_BORDER=GL_TEXTURE_BORDER;
GLenum kGL_DONT_CARE=GL_DONT_CARE;
GLenum kGL_FASTEST=GL_FASTEST;
GLenum kGL_NICEST=GL_NICEST;
GLenum kGL_LIGHT0=GL_LIGHT0;
GLenum kGL_LIGHT1=GL_LIGHT1;
GLenum kGL_LIGHT2=GL_LIGHT2;
GLenum kGL_LIGHT3=GL_LIGHT3;
GLenum kGL_LIGHT4=GL_LIGHT4;
GLenum kGL_LIGHT5=GL_LIGHT5;
GLenum kGL_LIGHT6=GL_LIGHT6;
GLenum kGL_LIGHT7=GL_LIGHT7;
GLenum kGL_AMBIENT=GL_AMBIENT;
GLenum kGL_DIFFUSE=GL_DIFFUSE;
GLenum kGL_SPECULAR=GL_SPECULAR;
GLenum kGL_POSITION=GL_POSITION;
GLenum kGL_SPOT_DIRECTION=GL_SPOT_DIRECTION;
GLenum kGL_SPOT_EXPONENT=GL_SPOT_EXPONENT;
GLenum kGL_SPOT_CUTOFF=GL_SPOT_CUTOFF;
GLenum kGL_CONSTANT_ATTENUATION=GL_CONSTANT_ATTENUATION;
GLenum kGL_LINEAR_ATTENUATION=GL_LINEAR_ATTENUATION;
GLenum kGL_QUADRATIC_ATTENUATION=GL_QUADRATIC_ATTENUATION;
GLenum kGL_COMPILE=GL_COMPILE;
GLenum kGL_COMPILE_AND_EXECUTE=GL_COMPILE_AND_EXECUTE;
GLenum kGL_CLEAR=GL_CLEAR;
GLenum kGL_AND=GL_AND;
GLenum kGL_AND_REVERSE=GL_AND_REVERSE;
GLenum kGL_COPY=GL_COPY;
GLenum kGL_AND_INVERTED=GL_AND_INVERTED;
GLenum kGL_NOOP=GL_NOOP;
GLenum kGL_XOR=GL_XOR;
GLenum kGL_OR=GL_OR;
GLenum kGL_NOR=GL_NOR;
GLenum kGL_EQUIV=GL_EQUIV;
GLenum kGL_INVERT=GL_INVERT;
GLenum kGL_OR_REVERSE=GL_OR_REVERSE;
GLenum kGL_COPY_INVERTED=GL_COPY_INVERTED;
GLenum kGL_OR_INVERTED=GL_OR_INVERTED;
GLenum kGL_NAND=GL_NAND;
GLenum kGL_SET=GL_SET;
GLenum kGL_EMISSION=GL_EMISSION;
GLenum kGL_SHININESS=GL_SHININESS;
GLenum kGL_AMBIENT_AND_DIFFUSE=GL_AMBIENT_AND_DIFFUSE;
GLenum kGL_COLOR_INDEXES=GL_COLOR_INDEXES;
GLenum kGL_MODELVIEW=GL_MODELVIEW;
GLenum kGL_PROJECTION=GL_PROJECTION;
GLenum kGL_TEXTURE=GL_TEXTURE;
GLenum kGL_COLOR=GL_COLOR;
GLenum kGL_DEPTH=GL_DEPTH;
GLenum kGL_STENCIL=GL_STENCIL;
GLenum kGL_COLOR_INDEX=GL_COLOR_INDEX;
GLenum kGL_STENCIL_INDEX=GL_STENCIL_INDEX;
GLenum kGL_DEPTH_COMPONENT=GL_DEPTH_COMPONENT;
GLenum kGL_RED=GL_RED;
GLenum kGL_GREEN=GL_GREEN;
GLenum kGL_BLUE=GL_BLUE;
GLenum kGL_ALPHA=GL_ALPHA;
GLenum kGL_RGB=GL_RGB;
GLenum kGL_RGBA=GL_RGBA;
GLenum kGL_LUMINANCE=GL_LUMINANCE;
GLenum kGL_LUMINANCE_ALPHA=GL_LUMINANCE_ALPHA;
GLenum kGL_BITMAP=GL_BITMAP;
GLenum kGL_POINT=GL_POINT;
GLenum kGL_LINE=GL_LINE;
GLenum kGL_FILL=GL_FILL;
GLenum kGL_RENDER=GL_RENDER;
GLenum kGL_FEEDBACK=GL_FEEDBACK;
GLenum kGL_SELECT=GL_SELECT;
GLenum kGL_FLAT=GL_FLAT;
GLenum kGL_SMOOTH=GL_SMOOTH;
GLenum kGL_KEEP=GL_KEEP;
GLenum kGL_REPLACE=GL_REPLACE;
GLenum kGL_INCR=GL_INCR;
GLenum kGL_DECR=GL_DECR;
GLenum kGL_VENDOR=GL_VENDOR;
GLenum kGL_RENDERER=GL_RENDERER;
GLenum kGL_VERSION=GL_VERSION;
GLenum kGL_EXTENSIONS=GL_EXTENSIONS;
GLenum kGL_S=GL_S;
GLenum kGL_T=GL_T;
GLenum kGL_R=GL_R;
GLenum kGL_Q=GL_Q;
GLenum kGL_MODULATE=GL_MODULATE;
GLenum kGL_DECAL=GL_DECAL;
GLenum kGL_TEXTURE_ENV_MODE=GL_TEXTURE_ENV_MODE;
GLenum kGL_TEXTURE_ENV_COLOR=GL_TEXTURE_ENV_COLOR;
GLenum kGL_TEXTURE_ENV=GL_TEXTURE_ENV;
GLenum kGL_EYE_LINEAR=GL_EYE_LINEAR;
GLenum kGL_OBJECT_LINEAR=GL_OBJECT_LINEAR;
GLenum kGL_SPHERE_MAP=GL_SPHERE_MAP;
GLenum kGL_TEXTURE_GEN_MODE=GL_TEXTURE_GEN_MODE;
GLenum kGL_OBJECT_PLANE=GL_OBJECT_PLANE;
GLenum kGL_EYE_PLANE=GL_EYE_PLANE;
GLenum kGL_NEAREST=GL_NEAREST;
GLenum kGL_LINEAR=GL_LINEAR;
GLenum kGL_NEAREST_MIPMAP_NEAREST=GL_NEAREST_MIPMAP_NEAREST;
GLenum kGL_LINEAR_MIPMAP_NEAREST=GL_LINEAR_MIPMAP_NEAREST;
GLenum kGL_NEAREST_MIPMAP_LINEAR=GL_NEAREST_MIPMAP_LINEAR;
GLenum kGL_LINEAR_MIPMAP_LINEAR=GL_LINEAR_MIPMAP_LINEAR;
GLenum kGL_TEXTURE_MAG_FILTER=GL_TEXTURE_MAG_FILTER;
GLenum kGL_TEXTURE_MIN_FILTER=GL_TEXTURE_MIN_FILTER;
GLenum kGL_TEXTURE_WRAP_S=GL_TEXTURE_WRAP_S;
GLenum kGL_TEXTURE_WRAP_T=GL_TEXTURE_WRAP_T;
GLenum kGL_CLAMP=GL_CLAMP;
GLenum kGL_REPEAT=GL_REPEAT;
GLbitfield kGL_CLIENT_PIXEL_STORE_BIT=GL_CLIENT_PIXEL_STORE_BIT;
GLbitfield kGL_CLIENT_VERTEX_ARRAY_BIT=GL_CLIENT_VERTEX_ARRAY_BIT;
GLenum kGL_CLIENT_ALL_ATTRIB_BITS=GL_CLIENT_ALL_ATTRIB_BITS;
GLenum kGL_POLYGON_OFFSET_FACTOR=GL_POLYGON_OFFSET_FACTOR;
GLenum kGL_POLYGON_OFFSET_UNITS=GL_POLYGON_OFFSET_UNITS;
GLenum kGL_POLYGON_OFFSET_POINT=GL_POLYGON_OFFSET_POINT;
GLenum kGL_POLYGON_OFFSET_LINE=GL_POLYGON_OFFSET_LINE;
GLenum kGL_POLYGON_OFFSET_FILL=GL_POLYGON_OFFSET_FILL;
GLenum kGL_ALPHA4=GL_ALPHA4;
GLenum kGL_ALPHA8=GL_ALPHA8;
GLenum kGL_ALPHA12=GL_ALPHA12;
GLenum kGL_ALPHA16=GL_ALPHA16;
GLenum kGL_LUMINANCE4=GL_LUMINANCE4;
GLenum kGL_LUMINANCE8=GL_LUMINANCE8;
GLenum kGL_LUMINANCE12=GL_LUMINANCE12;
GLenum kGL_LUMINANCE16=GL_LUMINANCE16;
GLenum kGL_LUMINANCE4_ALPHA4=GL_LUMINANCE4_ALPHA4;
GLenum kGL_LUMINANCE6_ALPHA2=GL_LUMINANCE6_ALPHA2;
GLenum kGL_LUMINANCE8_ALPHA8=GL_LUMINANCE8_ALPHA8;
GLenum kGL_LUMINANCE12_ALPHA4=GL_LUMINANCE12_ALPHA4;
GLenum kGL_LUMINANCE12_ALPHA12=GL_LUMINANCE12_ALPHA12;
GLenum kGL_LUMINANCE16_ALPHA16=GL_LUMINANCE16_ALPHA16;
GLenum kGL_INTENSITY=GL_INTENSITY;
GLenum kGL_INTENSITY4=GL_INTENSITY4;
GLenum kGL_INTENSITY8=GL_INTENSITY8;
GLenum kGL_INTENSITY12=GL_INTENSITY12;
GLenum kGL_INTENSITY16=GL_INTENSITY16;
GLenum kGL_R3_G3_B2=GL_R3_G3_B2;
GLenum kGL_RGB4=GL_RGB4;
GLenum kGL_RGB5=GL_RGB5;
GLenum kGL_RGB8=GL_RGB8;
GLenum kGL_RGB10=GL_RGB10;
GLenum kGL_RGB12=GL_RGB12;
GLenum kGL_RGB16=GL_RGB16;
GLenum kGL_RGBA2=GL_RGBA2;
GLenum kGL_RGBA4=GL_RGBA4;
GLenum kGL_RGB5_A1=GL_RGB5_A1;
GLenum kGL_RGBA8=GL_RGBA8;
GLenum kGL_RGB10_A2=GL_RGB10_A2;
GLenum kGL_RGBA12=GL_RGBA12;
GLenum kGL_RGBA16=GL_RGBA16;
GLenum kGL_TEXTURE_RED_SIZE=GL_TEXTURE_RED_SIZE;
GLenum kGL_TEXTURE_GREEN_SIZE=GL_TEXTURE_GREEN_SIZE;
GLenum kGL_TEXTURE_BLUE_SIZE=GL_TEXTURE_BLUE_SIZE;
GLenum kGL_TEXTURE_ALPHA_SIZE=GL_TEXTURE_ALPHA_SIZE;
GLenum kGL_TEXTURE_LUMINANCE_SIZE=GL_TEXTURE_LUMINANCE_SIZE;
GLenum kGL_TEXTURE_INTENSITY_SIZE=GL_TEXTURE_INTENSITY_SIZE;
GLenum kGL_PROXY_TEXTURE_1D=GL_PROXY_TEXTURE_1D;
GLenum kGL_PROXY_TEXTURE_2D=GL_PROXY_TEXTURE_2D;
GLenum kGL_TEXTURE_PRIORITY=GL_TEXTURE_PRIORITY;
GLenum kGL_TEXTURE_RESIDENT=GL_TEXTURE_RESIDENT;
GLenum kGL_TEXTURE_BINDING_1D=GL_TEXTURE_BINDING_1D;
GLenum kGL_TEXTURE_BINDING_2D=GL_TEXTURE_BINDING_2D;
GLenum kGL_VERTEX_ARRAY=GL_VERTEX_ARRAY;
GLenum kGL_NORMAL_ARRAY=GL_NORMAL_ARRAY;
GLenum kGL_COLOR_ARRAY=GL_COLOR_ARRAY;
GLenum kGL_INDEX_ARRAY=GL_INDEX_ARRAY;
GLenum kGL_TEXTURE_COORD_ARRAY=GL_TEXTURE_COORD_ARRAY;
GLenum kGL_EDGE_FLAG_ARRAY=GL_EDGE_FLAG_ARRAY;
GLenum kGL_VERTEX_ARRAY_SIZE=GL_VERTEX_ARRAY_SIZE;
GLenum kGL_VERTEX_ARRAY_TYPE=GL_VERTEX_ARRAY_TYPE;
GLenum kGL_VERTEX_ARRAY_STRIDE=GL_VERTEX_ARRAY_STRIDE;
GLenum kGL_NORMAL_ARRAY_TYPE=GL_NORMAL_ARRAY_TYPE;
GLenum kGL_NORMAL_ARRAY_STRIDE=GL_NORMAL_ARRAY_STRIDE;
GLenum kGL_COLOR_ARRAY_SIZE=GL_COLOR_ARRAY_SIZE;
GLenum kGL_COLOR_ARRAY_TYPE=GL_COLOR_ARRAY_TYPE;
GLenum kGL_COLOR_ARRAY_STRIDE=GL_COLOR_ARRAY_STRIDE;
GLenum kGL_INDEX_ARRAY_TYPE=GL_INDEX_ARRAY_TYPE;
GLenum kGL_INDEX_ARRAY_STRIDE=GL_INDEX_ARRAY_STRIDE;
GLenum kGL_TEXTURE_COORD_ARRAY_SIZE=GL_TEXTURE_COORD_ARRAY_SIZE;
GLenum kGL_TEXTURE_COORD_ARRAY_TYPE=GL_TEXTURE_COORD_ARRAY_TYPE;
GLenum kGL_TEXTURE_COORD_ARRAY_STRIDE=GL_TEXTURE_COORD_ARRAY_STRIDE;
GLenum kGL_EDGE_FLAG_ARRAY_STRIDE=GL_EDGE_FLAG_ARRAY_STRIDE;
GLenum kGL_VERTEX_ARRAY_POINTER=GL_VERTEX_ARRAY_POINTER;
GLenum kGL_NORMAL_ARRAY_POINTER=GL_NORMAL_ARRAY_POINTER;
GLenum kGL_COLOR_ARRAY_POINTER=GL_COLOR_ARRAY_POINTER;
GLenum kGL_INDEX_ARRAY_POINTER=GL_INDEX_ARRAY_POINTER;
GLenum kGL_TEXTURE_COORD_ARRAY_POINTER=GL_TEXTURE_COORD_ARRAY_POINTER;
GLenum kGL_EDGE_FLAG_ARRAY_POINTER=GL_EDGE_FLAG_ARRAY_POINTER;
GLenum kGL_V2F=GL_V2F;
GLenum kGL_V3F=GL_V3F;
GLenum kGL_C4UB_V2F=GL_C4UB_V2F;
GLenum kGL_C4UB_V3F=GL_C4UB_V3F;
GLenum kGL_C3F_V3F=GL_C3F_V3F;
GLenum kGL_N3F_V3F=GL_N3F_V3F;
GLenum kGL_C4F_N3F_V3F=GL_C4F_N3F_V3F;
GLenum kGL_T2F_V3F=GL_T2F_V3F;
GLenum kGL_T4F_V4F=GL_T4F_V4F;
GLenum kGL_T2F_C4UB_V3F=GL_T2F_C4UB_V3F;
GLenum kGL_T2F_C3F_V3F=GL_T2F_C3F_V3F;
GLenum kGL_T2F_N3F_V3F=GL_T2F_N3F_V3F;
GLenum kGL_T2F_C4F_N3F_V3F=GL_T2F_C4F_N3F_V3F;
GLenum kGL_T4F_C4F_N3F_V4F=GL_T4F_C4F_N3F_V4F;
GLenum kGL_EXT_vertex_array=GL_EXT_vertex_array;
GLenum kGL_EXT_bgra=GL_EXT_bgra;
GLenum kGL_EXT_paletted_texture=GL_EXT_paletted_texture;
// GLenum kGL_WIN_swap_hint=GL_WIN_swap_hint;
// GLenum kGL_WIN_draw_range_elements=GL_WIN_draw_range_elements;
GLenum kGL_VERTEX_ARRAY_EXT=GL_VERTEX_ARRAY_EXT;
GLenum kGL_NORMAL_ARRAY_EXT=GL_NORMAL_ARRAY_EXT;
GLenum kGL_COLOR_ARRAY_EXT=GL_COLOR_ARRAY_EXT;
GLenum kGL_INDEX_ARRAY_EXT=GL_INDEX_ARRAY_EXT;
GLenum kGL_TEXTURE_COORD_ARRAY_EXT=GL_TEXTURE_COORD_ARRAY_EXT;
GLenum kGL_EDGE_FLAG_ARRAY_EXT=GL_EDGE_FLAG_ARRAY_EXT;
GLenum kGL_VERTEX_ARRAY_SIZE_EXT=GL_VERTEX_ARRAY_SIZE_EXT;
GLenum kGL_VERTEX_ARRAY_TYPE_EXT=GL_VERTEX_ARRAY_TYPE_EXT;
GLenum kGL_VERTEX_ARRAY_STRIDE_EXT=GL_VERTEX_ARRAY_STRIDE_EXT;
GLenum kGL_VERTEX_ARRAY_COUNT_EXT=GL_VERTEX_ARRAY_COUNT_EXT;
GLenum kGL_NORMAL_ARRAY_TYPE_EXT=GL_NORMAL_ARRAY_TYPE_EXT;
GLenum kGL_NORMAL_ARRAY_STRIDE_EXT=GL_NORMAL_ARRAY_STRIDE_EXT;
GLenum kGL_NORMAL_ARRAY_COUNT_EXT=GL_NORMAL_ARRAY_COUNT_EXT;
GLenum kGL_COLOR_ARRAY_SIZE_EXT=GL_COLOR_ARRAY_SIZE_EXT;
GLenum kGL_COLOR_ARRAY_TYPE_EXT=GL_COLOR_ARRAY_TYPE_EXT;
GLenum kGL_COLOR_ARRAY_STRIDE_EXT=GL_COLOR_ARRAY_STRIDE_EXT;
GLenum kGL_COLOR_ARRAY_COUNT_EXT=GL_COLOR_ARRAY_COUNT_EXT;
GLenum kGL_INDEX_ARRAY_TYPE_EXT=GL_INDEX_ARRAY_TYPE_EXT;
GLenum kGL_INDEX_ARRAY_STRIDE_EXT=GL_INDEX_ARRAY_STRIDE_EXT;
GLenum kGL_INDEX_ARRAY_COUNT_EXT=GL_INDEX_ARRAY_COUNT_EXT;
GLenum kGL_TEXTURE_COORD_ARRAY_SIZE_EXT=GL_TEXTURE_COORD_ARRAY_SIZE_EXT;
GLenum kGL_TEXTURE_COORD_ARRAY_TYPE_EXT=GL_TEXTURE_COORD_ARRAY_TYPE_EXT;
GLenum kGL_TEXTURE_COORD_ARRAY_STRIDE_EXT=GL_TEXTURE_COORD_ARRAY_STRIDE_EXT;
GLenum kGL_TEXTURE_COORD_ARRAY_COUNT_EXT=GL_TEXTURE_COORD_ARRAY_COUNT_EXT;
GLenum kGL_EDGE_FLAG_ARRAY_STRIDE_EXT=GL_EDGE_FLAG_ARRAY_STRIDE_EXT;
GLenum kGL_EDGE_FLAG_ARRAY_COUNT_EXT=GL_EDGE_FLAG_ARRAY_COUNT_EXT;
GLenum kGL_VERTEX_ARRAY_POINTER_EXT=GL_VERTEX_ARRAY_POINTER_EXT;
GLenum kGL_NORMAL_ARRAY_POINTER_EXT=GL_NORMAL_ARRAY_POINTER_EXT;
GLenum kGL_COLOR_ARRAY_POINTER_EXT=GL_COLOR_ARRAY_POINTER_EXT;
GLenum kGL_INDEX_ARRAY_POINTER_EXT=GL_INDEX_ARRAY_POINTER_EXT;
GLenum kGL_TEXTURE_COORD_ARRAY_POINTER_EXT=GL_TEXTURE_COORD_ARRAY_POINTER_EXT;
GLenum kGL_EDGE_FLAG_ARRAY_POINTER_EXT=GL_EDGE_FLAG_ARRAY_POINTER_EXT;
// GLenum kGL_DOUBLE_EXT=GL_DOUBLE_EXT;
GLenum kGL_BGR_EXT=GL_BGR_EXT;
GLenum kGL_BGRA_EXT=GL_BGRA_EXT;
// GLenum kGL_COLOR_TABLE_FORMAT_EXT=GL_COLOR_TABLE_FORMAT_EXT;
// GLenum kGL_COLOR_TABLE_WIDTH_EXT=GL_COLOR_TABLE_WIDTH_EXT;
// GLenum kGL_COLOR_TABLE_RED_SIZE_EXT=GL_COLOR_TABLE_RED_SIZE_EXT;
// GLenum kGL_COLOR_TABLE_GREEN_SIZE_EXT=GL_COLOR_TABLE_GREEN_SIZE_EXT;
// GLenum kGL_COLOR_TABLE_BLUE_SIZE_EXT=GL_COLOR_TABLE_BLUE_SIZE_EXT;
// GLenum kGL_COLOR_TABLE_ALPHA_SIZE_EXT=GL_COLOR_TABLE_ALPHA_SIZE_EXT;
// GLenum kGL_COLOR_TABLE_LUMINANCE_SIZE_EXT=GL_COLOR_TABLE_LUMINANCE_SIZE_EXT;
// GLenum kGL_COLOR_TABLE_INTENSITY_SIZE_EXT=GL_COLOR_TABLE_INTENSITY_SIZE_EXT;
GLenum kGL_COLOR_INDEX1_EXT=GL_COLOR_INDEX1_EXT;
GLenum kGL_COLOR_INDEX2_EXT=GL_COLOR_INDEX2_EXT;
GLenum kGL_COLOR_INDEX4_EXT=GL_COLOR_INDEX4_EXT;
GLenum kGL_COLOR_INDEX8_EXT=GL_COLOR_INDEX8_EXT;
GLenum kGL_COLOR_INDEX12_EXT=GL_COLOR_INDEX12_EXT;
GLenum kGL_COLOR_INDEX16_EXT=GL_COLOR_INDEX16_EXT;
// GLenum kGL_MAX_ELEMENTS_VERTICES_WIN=GL_MAX_ELEMENTS_VERTICES_WIN;
// GLenum kGL_MAX_ELEMENTS_INDICES_WIN=GL_MAX_ELEMENTS_INDICES_WIN;
// GLenum kGL_PHONG_WIN=GL_PHONG_WIN;
// GLenum kGL_PHONG_HINT_WIN=GL_PHONG_HINT_WIN;
// GLenum kGL_FOG_SPECULAR_TEXTURE_WIN=GL_FOG_SPECULAR_TEXTURE_WIN;
GLenum kGL_LOGIC_OP=GL_LOGIC_OP;
GLenum kGL_TEXTURE_COMPONENTS=GL_TEXTURE_COMPONENTS;


#include "angelscript/add_on/scriptarray/scriptarray.h"

void as_glLightfv(GLenum light, GLenum pname, const CScriptArray& a)
{
    // unsafe direct memory access (read only)
    ///@todo check length depending on enum value for safety
    return glLightfv(light,pname,(const GLfloat*)a.At(0));
}
void as_glLightiv(GLenum light, GLenum pname, const CScriptArray& a)
{
    // unsafe direct memory access (read only)
    ///@todo check length depending on enum value for safety
    return glLightiv(light,pname,(const GLint*)a.At(0));
}

void as_glMaterialfv(GLenum face, GLenum pname,const CScriptArray& a)
{
    // unsafe direct memory access (read only)
    return glMaterialfv(face,pname,(const GLfloat*)a.At(0));
}

void as_glMaterialiv(GLenum face, GLenum pname,const CScriptArray& a)
{
    // unsafe direct memory access (read only)
    return glMaterialiv(face,pname,(const GLint*)a.At(0));
}

void RegisterOpenGL_Native(asIScriptEngine *engine)
{
    int r;

    r=engine->RegisterTypedef("GLenum","uint"); assert(r>=0);
    r=engine->RegisterTypedef("GLboolean","uint8"); assert(r>=0);
    r=engine->RegisterTypedef("GLbitfield","uint"); assert(r>=0);
    r=engine->RegisterTypedef("GLbyte","int8"); assert(r>=0);
    r=engine->RegisterTypedef("GLshort","int16"); assert(r>=0);
    r=engine->RegisterTypedef("GLint","int"); assert(r>=0);
    r=engine->RegisterTypedef("GLsizei","int"); assert(r>=0);
    r=engine->RegisterTypedef("GLubyte","uint8"); assert(r>=0);
    r=engine->RegisterTypedef("GLushort","uint16"); assert(r>=0);
    r=engine->RegisterTypedef("GLuint","uint"); assert(r>=0);
    r=engine->RegisterTypedef("GLfloat","float"); assert(r>=0);
    r=engine->RegisterTypedef("GLclampf","float"); assert(r>=0);
    r=engine->RegisterTypedef("GLdouble","double"); assert(r>=0);
    r=engine->RegisterTypedef("GLclampd","double"); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_VERSION_1_1" , &kGL_VERSION_1_1); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_ACCUM" , &kGL_ACCUM); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LOAD" , &kGL_LOAD); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RETURN" , &kGL_RETURN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MULT" , &kGL_MULT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ADD" , &kGL_ADD); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_NEVER" , &kGL_NEVER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LESS" , &kGL_LESS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EQUAL" , &kGL_EQUAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LEQUAL" , &kGL_LEQUAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_GREATER" , &kGL_GREATER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NOTEQUAL" , &kGL_NOTEQUAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_GEQUAL" , &kGL_GEQUAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALWAYS" , &kGL_ALWAYS); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLbitfield GL_CURRENT_BIT" , &kGL_CURRENT_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_POINT_BIT" , &kGL_POINT_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_LINE_BIT" , &kGL_LINE_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_POLYGON_BIT" , &kGL_POLYGON_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_POLYGON_STIPPLE_BIT" , &kGL_POLYGON_STIPPLE_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_PIXEL_MODE_BIT" , &kGL_PIXEL_MODE_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_LIGHTING_BIT" , &kGL_LIGHTING_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_FOG_BIT" , &kGL_FOG_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_DEPTH_BUFFER_BIT" , &kGL_DEPTH_BUFFER_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_ACCUM_BUFFER_BIT" , &kGL_ACCUM_BUFFER_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_STENCIL_BUFFER_BIT" , &kGL_STENCIL_BUFFER_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_VIEWPORT_BIT" , &kGL_VIEWPORT_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_TRANSFORM_BIT" , &kGL_TRANSFORM_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_ENABLE_BIT" , &kGL_ENABLE_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_COLOR_BUFFER_BIT" , &kGL_COLOR_BUFFER_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_HINT_BIT" , &kGL_HINT_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_EVAL_BIT" , &kGL_EVAL_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_LIST_BIT" , &kGL_LIST_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_TEXTURE_BIT" , &kGL_TEXTURE_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_SCISSOR_BIT" , &kGL_SCISSOR_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALL_ATTRIB_BITS" , &kGL_ALL_ATTRIB_BITS); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_POINTS" , &kGL_POINTS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINES" , &kGL_LINES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_LOOP" , &kGL_LINE_LOOP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_STRIP" , &kGL_LINE_STRIP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TRIANGLES" , &kGL_TRIANGLES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TRIANGLE_STRIP" , &kGL_TRIANGLE_STRIP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TRIANGLE_FAN" , &kGL_TRIANGLE_FAN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_QUADS" , &kGL_QUADS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_QUAD_STRIP" , &kGL_QUAD_STRIP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON" , &kGL_POLYGON); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_ZERO" , &kGL_ZERO); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ONE" , &kGL_ONE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SRC_COLOR" , &kGL_SRC_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ONE_MINUS_SRC_COLOR" , &kGL_ONE_MINUS_SRC_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SRC_ALPHA" , &kGL_SRC_ALPHA); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ONE_MINUS_SRC_ALPHA" , &kGL_ONE_MINUS_SRC_ALPHA); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DST_ALPHA" , &kGL_DST_ALPHA); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ONE_MINUS_DST_ALPHA" , &kGL_ONE_MINUS_DST_ALPHA); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_DST_COLOR" , &kGL_DST_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ONE_MINUS_DST_COLOR" , &kGL_ONE_MINUS_DST_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SRC_ALPHA_SATURATE" , &kGL_SRC_ALPHA_SATURATE); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TRUE" , &kGL_TRUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FALSE" , &kGL_FALSE); assert(r>=0);



    r=engine->RegisterGlobalProperty("const GLenum GL_CLIP_PLANE0" , &kGL_CLIP_PLANE0); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIP_PLANE1" , &kGL_CLIP_PLANE1); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIP_PLANE2" , &kGL_CLIP_PLANE2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIP_PLANE3" , &kGL_CLIP_PLANE3); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIP_PLANE4" , &kGL_CLIP_PLANE4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIP_PLANE5" , &kGL_CLIP_PLANE5); assert(r>=0);





    r=engine->RegisterGlobalProperty("const GLenum GL_BYTE" , &kGL_BYTE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNSIGNED_BYTE" , &kGL_UNSIGNED_BYTE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SHORT" , &kGL_SHORT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNSIGNED_SHORT" , &kGL_UNSIGNED_SHORT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INT" , &kGL_INT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNSIGNED_INT" , &kGL_UNSIGNED_INT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FLOAT" , &kGL_FLOAT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_2_BYTES" , &kGL_2_BYTES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_3_BYTES" , &kGL_3_BYTES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_4_BYTES" , &kGL_4_BYTES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DOUBLE" , &kGL_DOUBLE); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_NONE" , &kGL_NONE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FRONT_LEFT" , &kGL_FRONT_LEFT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FRONT_RIGHT" , &kGL_FRONT_RIGHT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BACK_LEFT" , &kGL_BACK_LEFT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BACK_RIGHT" , &kGL_BACK_RIGHT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FRONT" , &kGL_FRONT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BACK" , &kGL_BACK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LEFT" , &kGL_LEFT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RIGHT" , &kGL_RIGHT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FRONT_AND_BACK" , &kGL_FRONT_AND_BACK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AUX0" , &kGL_AUX0); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AUX1" , &kGL_AUX1); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AUX2" , &kGL_AUX2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AUX3" , &kGL_AUX3); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_NO_ERROR" , &kGL_NO_ERROR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INVALID_ENUM" , &kGL_INVALID_ENUM); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INVALID_VALUE" , &kGL_INVALID_VALUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INVALID_OPERATION" , &kGL_INVALID_OPERATION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STACK_OVERFLOW" , &kGL_STACK_OVERFLOW); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STACK_UNDERFLOW" , &kGL_STACK_UNDERFLOW); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_OUT_OF_MEMORY" , &kGL_OUT_OF_MEMORY); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_2D" , &kGL_2D); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_3D" , &kGL_3D); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_3D_COLOR" , &kGL_3D_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_3D_COLOR_TEXTURE" , &kGL_3D_COLOR_TEXTURE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_4D_COLOR_TEXTURE" , &kGL_4D_COLOR_TEXTURE); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_PASS_THROUGH_TOKEN" , &kGL_PASS_THROUGH_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POINT_TOKEN" , &kGL_POINT_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_TOKEN" , &kGL_LINE_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_TOKEN" , &kGL_POLYGON_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BITMAP_TOKEN" , &kGL_BITMAP_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DRAW_PIXEL_TOKEN" , &kGL_DRAW_PIXEL_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COPY_PIXEL_TOKEN" , &kGL_COPY_PIXEL_TOKEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_RESET_TOKEN" , &kGL_LINE_RESET_TOKEN); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_EXP" , &kGL_EXP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EXP2" , &kGL_EXP2); assert(r>=0);



    r=engine->RegisterGlobalProperty("const GLenum GL_CW" , &kGL_CW); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CCW" , &kGL_CCW); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_COEFF" , &kGL_COEFF); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ORDER" , &kGL_ORDER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DOMAIN" , &kGL_DOMAIN); assert(r>=0);



    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_COLOR" , &kGL_CURRENT_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_INDEX" , &kGL_CURRENT_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_NORMAL" , &kGL_CURRENT_NORMAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_TEXTURE_COORDS" , &kGL_CURRENT_TEXTURE_COORDS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_RASTER_COLOR" , &kGL_CURRENT_RASTER_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_RASTER_INDEX" , &kGL_CURRENT_RASTER_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_RASTER_TEXTURE_COORDS" , &kGL_CURRENT_RASTER_TEXTURE_COORDS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_RASTER_POSITION" , &kGL_CURRENT_RASTER_POSITION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_RASTER_POSITION_VALID" , &kGL_CURRENT_RASTER_POSITION_VALID); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CURRENT_RASTER_DISTANCE" , &kGL_CURRENT_RASTER_DISTANCE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POINT_SMOOTH" , &kGL_POINT_SMOOTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POINT_SIZE" , &kGL_POINT_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POINT_SIZE_RANGE" , &kGL_POINT_SIZE_RANGE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POINT_SIZE_GRANULARITY" , &kGL_POINT_SIZE_GRANULARITY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_SMOOTH" , &kGL_LINE_SMOOTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_WIDTH" , &kGL_LINE_WIDTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_WIDTH_RANGE" , &kGL_LINE_WIDTH_RANGE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_WIDTH_GRANULARITY" , &kGL_LINE_WIDTH_GRANULARITY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_STIPPLE" , &kGL_LINE_STIPPLE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_STIPPLE_PATTERN" , &kGL_LINE_STIPPLE_PATTERN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_STIPPLE_REPEAT" , &kGL_LINE_STIPPLE_REPEAT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIST_MODE" , &kGL_LIST_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_LIST_NESTING" , &kGL_MAX_LIST_NESTING); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIST_BASE" , &kGL_LIST_BASE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIST_INDEX" , &kGL_LIST_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_MODE" , &kGL_POLYGON_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_SMOOTH" , &kGL_POLYGON_SMOOTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_STIPPLE" , &kGL_POLYGON_STIPPLE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG" , &kGL_EDGE_FLAG); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CULL_FACE" , &kGL_CULL_FACE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CULL_FACE_MODE" , &kGL_CULL_FACE_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FRONT_FACE" , &kGL_FRONT_FACE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHTING" , &kGL_LIGHTING); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT_MODEL_LOCAL_VIEWER" , &kGL_LIGHT_MODEL_LOCAL_VIEWER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT_MODEL_TWO_SIDE" , &kGL_LIGHT_MODEL_TWO_SIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT_MODEL_AMBIENT" , &kGL_LIGHT_MODEL_AMBIENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SHADE_MODEL" , &kGL_SHADE_MODEL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_MATERIAL_FACE" , &kGL_COLOR_MATERIAL_FACE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_MATERIAL_PARAMETER" , &kGL_COLOR_MATERIAL_PARAMETER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_MATERIAL" , &kGL_COLOR_MATERIAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG" , &kGL_FOG); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_INDEX" , &kGL_FOG_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_DENSITY" , &kGL_FOG_DENSITY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_START" , &kGL_FOG_START); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_END" , &kGL_FOG_END); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_MODE" , &kGL_FOG_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_COLOR" , &kGL_FOG_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_RANGE" , &kGL_DEPTH_RANGE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_TEST" , &kGL_DEPTH_TEST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_WRITEMASK" , &kGL_DEPTH_WRITEMASK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_CLEAR_VALUE" , &kGL_DEPTH_CLEAR_VALUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_FUNC" , &kGL_DEPTH_FUNC); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ACCUM_CLEAR_VALUE" , &kGL_ACCUM_CLEAR_VALUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_TEST" , &kGL_STENCIL_TEST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_CLEAR_VALUE" , &kGL_STENCIL_CLEAR_VALUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_FUNC" , &kGL_STENCIL_FUNC); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_VALUE_MASK" , &kGL_STENCIL_VALUE_MASK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_FAIL" , &kGL_STENCIL_FAIL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_PASS_DEPTH_FAIL" , &kGL_STENCIL_PASS_DEPTH_FAIL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_PASS_DEPTH_PASS" , &kGL_STENCIL_PASS_DEPTH_PASS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_REF" , &kGL_STENCIL_REF); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_WRITEMASK" , &kGL_STENCIL_WRITEMASK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MATRIX_MODE" , &kGL_MATRIX_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMALIZE" , &kGL_NORMALIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VIEWPORT" , &kGL_VIEWPORT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MODELVIEW_STACK_DEPTH" , &kGL_MODELVIEW_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PROJECTION_STACK_DEPTH" , &kGL_PROJECTION_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_STACK_DEPTH" , &kGL_TEXTURE_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MODELVIEW_MATRIX" , &kGL_MODELVIEW_MATRIX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PROJECTION_MATRIX" , &kGL_PROJECTION_MATRIX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_MATRIX" , &kGL_TEXTURE_MATRIX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ATTRIB_STACK_DEPTH" , &kGL_ATTRIB_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIENT_ATTRIB_STACK_DEPTH" , &kGL_CLIENT_ATTRIB_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA_TEST" , &kGL_ALPHA_TEST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA_TEST_FUNC" , &kGL_ALPHA_TEST_FUNC); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA_TEST_REF" , &kGL_ALPHA_TEST_REF); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DITHER" , &kGL_DITHER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLEND_DST" , &kGL_BLEND_DST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLEND_SRC" , &kGL_BLEND_SRC); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLEND" , &kGL_BLEND); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LOGIC_OP_MODE" , &kGL_LOGIC_OP_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_LOGIC_OP" , &kGL_INDEX_LOGIC_OP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_LOGIC_OP" , &kGL_COLOR_LOGIC_OP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AUX_BUFFERS" , &kGL_AUX_BUFFERS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DRAW_BUFFER" , &kGL_DRAW_BUFFER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_READ_BUFFER" , &kGL_READ_BUFFER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SCISSOR_BOX" , &kGL_SCISSOR_BOX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SCISSOR_TEST" , &kGL_SCISSOR_TEST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_CLEAR_VALUE" , &kGL_INDEX_CLEAR_VALUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_WRITEMASK" , &kGL_INDEX_WRITEMASK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_CLEAR_VALUE" , &kGL_COLOR_CLEAR_VALUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_WRITEMASK" , &kGL_COLOR_WRITEMASK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_MODE" , &kGL_INDEX_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA_MODE" , &kGL_RGBA_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DOUBLEBUFFER" , &kGL_DOUBLEBUFFER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STEREO" , &kGL_STEREO); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RENDER_MODE" , &kGL_RENDER_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PERSPECTIVE_CORRECTION_HINT" , &kGL_PERSPECTIVE_CORRECTION_HINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POINT_SMOOTH_HINT" , &kGL_POINT_SMOOTH_HINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE_SMOOTH_HINT" , &kGL_LINE_SMOOTH_HINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_SMOOTH_HINT" , &kGL_POLYGON_SMOOTH_HINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FOG_HINT" , &kGL_FOG_HINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_GEN_S" , &kGL_TEXTURE_GEN_S); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_GEN_T" , &kGL_TEXTURE_GEN_T); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_GEN_R" , &kGL_TEXTURE_GEN_R); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_GEN_Q" , &kGL_TEXTURE_GEN_Q); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_I" , &kGL_PIXEL_MAP_I_TO_I); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_S_TO_S" , &kGL_PIXEL_MAP_S_TO_S); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_R" , &kGL_PIXEL_MAP_I_TO_R); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_G" , &kGL_PIXEL_MAP_I_TO_G); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_B" , &kGL_PIXEL_MAP_I_TO_B); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_A" , &kGL_PIXEL_MAP_I_TO_A); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_R_TO_R" , &kGL_PIXEL_MAP_R_TO_R); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_G_TO_G" , &kGL_PIXEL_MAP_G_TO_G); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_B_TO_B" , &kGL_PIXEL_MAP_B_TO_B); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_A_TO_A" , &kGL_PIXEL_MAP_A_TO_A); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_I_SIZE" , &kGL_PIXEL_MAP_I_TO_I_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_S_TO_S_SIZE" , &kGL_PIXEL_MAP_S_TO_S_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_R_SIZE" , &kGL_PIXEL_MAP_I_TO_R_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_G_SIZE" , &kGL_PIXEL_MAP_I_TO_G_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_B_SIZE" , &kGL_PIXEL_MAP_I_TO_B_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_I_TO_A_SIZE" , &kGL_PIXEL_MAP_I_TO_A_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_R_TO_R_SIZE" , &kGL_PIXEL_MAP_R_TO_R_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_G_TO_G_SIZE" , &kGL_PIXEL_MAP_G_TO_G_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_B_TO_B_SIZE" , &kGL_PIXEL_MAP_B_TO_B_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PIXEL_MAP_A_TO_A_SIZE" , &kGL_PIXEL_MAP_A_TO_A_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNPACK_SWAP_BYTES" , &kGL_UNPACK_SWAP_BYTES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNPACK_LSB_FIRST" , &kGL_UNPACK_LSB_FIRST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNPACK_ROW_LENGTH" , &kGL_UNPACK_ROW_LENGTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNPACK_SKIP_ROWS" , &kGL_UNPACK_SKIP_ROWS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNPACK_SKIP_PIXELS" , &kGL_UNPACK_SKIP_PIXELS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_UNPACK_ALIGNMENT" , &kGL_UNPACK_ALIGNMENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PACK_SWAP_BYTES" , &kGL_PACK_SWAP_BYTES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PACK_LSB_FIRST" , &kGL_PACK_LSB_FIRST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PACK_ROW_LENGTH" , &kGL_PACK_ROW_LENGTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PACK_SKIP_ROWS" , &kGL_PACK_SKIP_ROWS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PACK_SKIP_PIXELS" , &kGL_PACK_SKIP_PIXELS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PACK_ALIGNMENT" , &kGL_PACK_ALIGNMENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP_COLOR" , &kGL_MAP_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP_STENCIL" , &kGL_MAP_STENCIL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_SHIFT" , &kGL_INDEX_SHIFT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_OFFSET" , &kGL_INDEX_OFFSET); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RED_SCALE" , &kGL_RED_SCALE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RED_BIAS" , &kGL_RED_BIAS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ZOOM_X" , &kGL_ZOOM_X); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ZOOM_Y" , &kGL_ZOOM_Y); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_GREEN_SCALE" , &kGL_GREEN_SCALE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_GREEN_BIAS" , &kGL_GREEN_BIAS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLUE_SCALE" , &kGL_BLUE_SCALE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLUE_BIAS" , &kGL_BLUE_BIAS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA_SCALE" , &kGL_ALPHA_SCALE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA_BIAS" , &kGL_ALPHA_BIAS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_SCALE" , &kGL_DEPTH_SCALE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_BIAS" , &kGL_DEPTH_BIAS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_EVAL_ORDER" , &kGL_MAX_EVAL_ORDER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_LIGHTS" , &kGL_MAX_LIGHTS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_CLIP_PLANES" , &kGL_MAX_CLIP_PLANES); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_TEXTURE_SIZE" , &kGL_MAX_TEXTURE_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_PIXEL_MAP_TABLE" , &kGL_MAX_PIXEL_MAP_TABLE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_ATTRIB_STACK_DEPTH" , &kGL_MAX_ATTRIB_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_MODELVIEW_STACK_DEPTH" , &kGL_MAX_MODELVIEW_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_NAME_STACK_DEPTH" , &kGL_MAX_NAME_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_PROJECTION_STACK_DEPTH" , &kGL_MAX_PROJECTION_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_TEXTURE_STACK_DEPTH" , &kGL_MAX_TEXTURE_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_VIEWPORT_DIMS" , &kGL_MAX_VIEWPORT_DIMS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAX_CLIENT_ATTRIB_STACK_DEPTH" , &kGL_MAX_CLIENT_ATTRIB_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SUBPIXEL_BITS" , &kGL_SUBPIXEL_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_BITS" , &kGL_INDEX_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RED_BITS" , &kGL_RED_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_GREEN_BITS" , &kGL_GREEN_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLUE_BITS" , &kGL_BLUE_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA_BITS" , &kGL_ALPHA_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_BITS" , &kGL_DEPTH_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_BITS" , &kGL_STENCIL_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ACCUM_RED_BITS" , &kGL_ACCUM_RED_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ACCUM_GREEN_BITS" , &kGL_ACCUM_GREEN_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ACCUM_BLUE_BITS" , &kGL_ACCUM_BLUE_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ACCUM_ALPHA_BITS" , &kGL_ACCUM_ALPHA_BITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NAME_STACK_DEPTH" , &kGL_NAME_STACK_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AUTO_NORMAL" , &kGL_AUTO_NORMAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_COLOR_4" , &kGL_MAP1_COLOR_4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_INDEX" , &kGL_MAP1_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_NORMAL" , &kGL_MAP1_NORMAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_TEXTURE_COORD_1" , &kGL_MAP1_TEXTURE_COORD_1); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_TEXTURE_COORD_2" , &kGL_MAP1_TEXTURE_COORD_2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_TEXTURE_COORD_3" , &kGL_MAP1_TEXTURE_COORD_3); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_TEXTURE_COORD_4" , &kGL_MAP1_TEXTURE_COORD_4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_VERTEX_3" , &kGL_MAP1_VERTEX_3); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_VERTEX_4" , &kGL_MAP1_VERTEX_4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_COLOR_4" , &kGL_MAP2_COLOR_4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_INDEX" , &kGL_MAP2_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_NORMAL" , &kGL_MAP2_NORMAL); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_TEXTURE_COORD_1" , &kGL_MAP2_TEXTURE_COORD_1); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_TEXTURE_COORD_2" , &kGL_MAP2_TEXTURE_COORD_2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_TEXTURE_COORD_3" , &kGL_MAP2_TEXTURE_COORD_3); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_TEXTURE_COORD_4" , &kGL_MAP2_TEXTURE_COORD_4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_VERTEX_3" , &kGL_MAP2_VERTEX_3); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_VERTEX_4" , &kGL_MAP2_VERTEX_4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_GRID_DOMAIN" , &kGL_MAP1_GRID_DOMAIN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP1_GRID_SEGMENTS" , &kGL_MAP1_GRID_SEGMENTS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_GRID_DOMAIN" , &kGL_MAP2_GRID_DOMAIN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_MAP2_GRID_SEGMENTS" , &kGL_MAP2_GRID_SEGMENTS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_1D" , &kGL_TEXTURE_1D); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_2D" , &kGL_TEXTURE_2D); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FEEDBACK_BUFFER_POINTER" , &kGL_FEEDBACK_BUFFER_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FEEDBACK_BUFFER_SIZE" , &kGL_FEEDBACK_BUFFER_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FEEDBACK_BUFFER_TYPE" , &kGL_FEEDBACK_BUFFER_TYPE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SELECTION_BUFFER_POINTER" , &kGL_SELECTION_BUFFER_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SELECTION_BUFFER_SIZE" , &kGL_SELECTION_BUFFER_SIZE); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_WIDTH" , &kGL_TEXTURE_WIDTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_HEIGHT" , &kGL_TEXTURE_HEIGHT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_INTERNAL_FORMAT" , &kGL_TEXTURE_INTERNAL_FORMAT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_BORDER_COLOR" , &kGL_TEXTURE_BORDER_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_BORDER" , &kGL_TEXTURE_BORDER); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_DONT_CARE" , &kGL_DONT_CARE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FASTEST" , &kGL_FASTEST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NICEST" , &kGL_NICEST); assert(r>=0);




    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT0" , &kGL_LIGHT0); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT1" , &kGL_LIGHT1); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT2" , &kGL_LIGHT2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT3" , &kGL_LIGHT3); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT4" , &kGL_LIGHT4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT5" , &kGL_LIGHT5); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT6" , &kGL_LIGHT6); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LIGHT7" , &kGL_LIGHT7); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_AMBIENT" , &kGL_AMBIENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DIFFUSE" , &kGL_DIFFUSE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SPECULAR" , &kGL_SPECULAR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POSITION" , &kGL_POSITION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SPOT_DIRECTION" , &kGL_SPOT_DIRECTION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SPOT_EXPONENT" , &kGL_SPOT_EXPONENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SPOT_CUTOFF" , &kGL_SPOT_CUTOFF); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CONSTANT_ATTENUATION" , &kGL_CONSTANT_ATTENUATION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINEAR_ATTENUATION" , &kGL_LINEAR_ATTENUATION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_QUADRATIC_ATTENUATION" , &kGL_QUADRATIC_ATTENUATION); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_COMPILE" , &kGL_COMPILE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COMPILE_AND_EXECUTE" , &kGL_COMPILE_AND_EXECUTE); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_CLEAR" , &kGL_CLEAR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AND" , &kGL_AND); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AND_REVERSE" , &kGL_AND_REVERSE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COPY" , &kGL_COPY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AND_INVERTED" , &kGL_AND_INVERTED); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NOOP" , &kGL_NOOP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_XOR" , &kGL_XOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_OR" , &kGL_OR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NOR" , &kGL_NOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EQUIV" , &kGL_EQUIV); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INVERT" , &kGL_INVERT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_OR_REVERSE" , &kGL_OR_REVERSE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COPY_INVERTED" , &kGL_COPY_INVERTED); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_OR_INVERTED" , &kGL_OR_INVERTED); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NAND" , &kGL_NAND); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SET" , &kGL_SET); assert(r>=0);



    r=engine->RegisterGlobalProperty("const GLenum GL_EMISSION" , &kGL_EMISSION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SHININESS" , &kGL_SHININESS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_AMBIENT_AND_DIFFUSE" , &kGL_AMBIENT_AND_DIFFUSE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEXES" , &kGL_COLOR_INDEXES); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_MODELVIEW" , &kGL_MODELVIEW); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PROJECTION" , &kGL_PROJECTION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE" , &kGL_TEXTURE); assert(r>=0);




    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR" , &kGL_COLOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH" , &kGL_DEPTH); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL" , &kGL_STENCIL); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX" , &kGL_COLOR_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_STENCIL_INDEX" , &kGL_STENCIL_INDEX); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DEPTH_COMPONENT" , &kGL_DEPTH_COMPONENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RED" , &kGL_RED); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_GREEN" , &kGL_GREEN); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BLUE" , &kGL_BLUE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA" , &kGL_ALPHA); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB" , &kGL_RGB); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA" , &kGL_RGBA); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE" , &kGL_LUMINANCE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE_ALPHA" , &kGL_LUMINANCE_ALPHA); assert(r>=0);




    r=engine->RegisterGlobalProperty("const GLenum GL_BITMAP" , &kGL_BITMAP); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_POINT" , &kGL_POINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINE" , &kGL_LINE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FILL" , &kGL_FILL); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_RENDER" , &kGL_RENDER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_FEEDBACK" , &kGL_FEEDBACK); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SELECT" , &kGL_SELECT); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_FLAT" , &kGL_FLAT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SMOOTH" , &kGL_SMOOTH); assert(r>=0);



    r=engine->RegisterGlobalProperty("const GLenum GL_KEEP" , &kGL_KEEP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_REPLACE" , &kGL_REPLACE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INCR" , &kGL_INCR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DECR" , &kGL_DECR); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_VENDOR" , &kGL_VENDOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RENDERER" , &kGL_RENDERER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERSION" , &kGL_VERSION); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EXTENSIONS" , &kGL_EXTENSIONS); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_S" , &kGL_S); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T" , &kGL_T); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_R" , &kGL_R); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_Q" , &kGL_Q); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_MODULATE" , &kGL_MODULATE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_DECAL" , &kGL_DECAL); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_ENV_MODE" , &kGL_TEXTURE_ENV_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_ENV_COLOR" , &kGL_TEXTURE_ENV_COLOR); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_ENV" , &kGL_TEXTURE_ENV); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_EYE_LINEAR" , &kGL_EYE_LINEAR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_OBJECT_LINEAR" , &kGL_OBJECT_LINEAR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_SPHERE_MAP" , &kGL_SPHERE_MAP); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_GEN_MODE" , &kGL_TEXTURE_GEN_MODE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_OBJECT_PLANE" , &kGL_OBJECT_PLANE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EYE_PLANE" , &kGL_EYE_PLANE); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_NEAREST" , &kGL_NEAREST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINEAR" , &kGL_LINEAR); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_NEAREST_MIPMAP_NEAREST" , &kGL_NEAREST_MIPMAP_NEAREST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINEAR_MIPMAP_NEAREST" , &kGL_LINEAR_MIPMAP_NEAREST); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NEAREST_MIPMAP_LINEAR" , &kGL_NEAREST_MIPMAP_LINEAR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LINEAR_MIPMAP_LINEAR" , &kGL_LINEAR_MIPMAP_LINEAR); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_MAG_FILTER" , &kGL_TEXTURE_MAG_FILTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_MIN_FILTER" , &kGL_TEXTURE_MIN_FILTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_WRAP_S" , &kGL_TEXTURE_WRAP_S); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_WRAP_T" , &kGL_TEXTURE_WRAP_T); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLenum GL_CLAMP" , &kGL_CLAMP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_REPEAT" , &kGL_REPEAT); assert(r>=0);


    r=engine->RegisterGlobalProperty("const GLbitfield GL_CLIENT_PIXEL_STORE_BIT" , &kGL_CLIENT_PIXEL_STORE_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLbitfield GL_CLIENT_VERTEX_ARRAY_BIT" , &kGL_CLIENT_VERTEX_ARRAY_BIT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_CLIENT_ALL_ATTRIB_BITS" , &kGL_CLIENT_ALL_ATTRIB_BITS); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_OFFSET_FACTOR" , &kGL_POLYGON_OFFSET_FACTOR); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_OFFSET_UNITS" , &kGL_POLYGON_OFFSET_UNITS); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_OFFSET_POINT" , &kGL_POLYGON_OFFSET_POINT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_OFFSET_LINE" , &kGL_POLYGON_OFFSET_LINE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_POLYGON_OFFSET_FILL" , &kGL_POLYGON_OFFSET_FILL); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA4" , &kGL_ALPHA4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA8" , &kGL_ALPHA8); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA12" , &kGL_ALPHA12); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_ALPHA16" , &kGL_ALPHA16); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE4" , &kGL_LUMINANCE4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE8" , &kGL_LUMINANCE8); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE12" , &kGL_LUMINANCE12); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE16" , &kGL_LUMINANCE16); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE4_ALPHA4" , &kGL_LUMINANCE4_ALPHA4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE6_ALPHA2" , &kGL_LUMINANCE6_ALPHA2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE8_ALPHA8" , &kGL_LUMINANCE8_ALPHA8); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE12_ALPHA4" , &kGL_LUMINANCE12_ALPHA4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE12_ALPHA12" , &kGL_LUMINANCE12_ALPHA12); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_LUMINANCE16_ALPHA16" , &kGL_LUMINANCE16_ALPHA16); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INTENSITY" , &kGL_INTENSITY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INTENSITY4" , &kGL_INTENSITY4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INTENSITY8" , &kGL_INTENSITY8); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INTENSITY12" , &kGL_INTENSITY12); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INTENSITY16" , &kGL_INTENSITY16); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_R3_G3_B2" , &kGL_R3_G3_B2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB4" , &kGL_RGB4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB5" , &kGL_RGB5); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB8" , &kGL_RGB8); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB10" , &kGL_RGB10); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB12" , &kGL_RGB12); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB16" , &kGL_RGB16); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA2" , &kGL_RGBA2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA4" , &kGL_RGBA4); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB5_A1" , &kGL_RGB5_A1); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA8" , &kGL_RGBA8); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGB10_A2" , &kGL_RGB10_A2); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA12" , &kGL_RGBA12); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_RGBA16" , &kGL_RGBA16); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_RED_SIZE" , &kGL_TEXTURE_RED_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_GREEN_SIZE" , &kGL_TEXTURE_GREEN_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_BLUE_SIZE" , &kGL_TEXTURE_BLUE_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_ALPHA_SIZE" , &kGL_TEXTURE_ALPHA_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_LUMINANCE_SIZE" , &kGL_TEXTURE_LUMINANCE_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_INTENSITY_SIZE" , &kGL_TEXTURE_INTENSITY_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PROXY_TEXTURE_1D" , &kGL_PROXY_TEXTURE_1D); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_PROXY_TEXTURE_2D" , &kGL_PROXY_TEXTURE_2D); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_PRIORITY" , &kGL_TEXTURE_PRIORITY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_RESIDENT" , &kGL_TEXTURE_RESIDENT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_BINDING_1D" , &kGL_TEXTURE_BINDING_1D); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_BINDING_2D" , &kGL_TEXTURE_BINDING_2D); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY" , &kGL_VERTEX_ARRAY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY" , &kGL_NORMAL_ARRAY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY" , &kGL_COLOR_ARRAY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY" , &kGL_INDEX_ARRAY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY" , &kGL_TEXTURE_COORD_ARRAY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY" , &kGL_EDGE_FLAG_ARRAY); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_SIZE" , &kGL_VERTEX_ARRAY_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_TYPE" , &kGL_VERTEX_ARRAY_TYPE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_STRIDE" , &kGL_VERTEX_ARRAY_STRIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_TYPE" , &kGL_NORMAL_ARRAY_TYPE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_STRIDE" , &kGL_NORMAL_ARRAY_STRIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_SIZE" , &kGL_COLOR_ARRAY_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_TYPE" , &kGL_COLOR_ARRAY_TYPE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_STRIDE" , &kGL_COLOR_ARRAY_STRIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_TYPE" , &kGL_INDEX_ARRAY_TYPE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_STRIDE" , &kGL_INDEX_ARRAY_STRIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_SIZE" , &kGL_TEXTURE_COORD_ARRAY_SIZE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_TYPE" , &kGL_TEXTURE_COORD_ARRAY_TYPE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_STRIDE" , &kGL_TEXTURE_COORD_ARRAY_STRIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY_STRIDE" , &kGL_EDGE_FLAG_ARRAY_STRIDE); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_POINTER" , &kGL_VERTEX_ARRAY_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_POINTER" , &kGL_NORMAL_ARRAY_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_POINTER" , &kGL_COLOR_ARRAY_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_POINTER" , &kGL_INDEX_ARRAY_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_POINTER" , &kGL_TEXTURE_COORD_ARRAY_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY_POINTER" , &kGL_EDGE_FLAG_ARRAY_POINTER); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_V2F" , &kGL_V2F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_V3F" , &kGL_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_C4UB_V2F" , &kGL_C4UB_V2F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_C4UB_V3F" , &kGL_C4UB_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_C3F_V3F" , &kGL_C3F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_N3F_V3F" , &kGL_N3F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_C4F_N3F_V3F" , &kGL_C4F_N3F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T2F_V3F" , &kGL_T2F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T4F_V4F" , &kGL_T4F_V4F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T2F_C4UB_V3F" , &kGL_T2F_C4UB_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T2F_C3F_V3F" , &kGL_T2F_C3F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T2F_N3F_V3F" , &kGL_T2F_N3F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T2F_C4F_N3F_V3F" , &kGL_T2F_C4F_N3F_V3F); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_T4F_C4F_N3F_V4F" , &kGL_T4F_C4F_N3F_V4F); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_EXT_vertex_array" , &kGL_EXT_vertex_array); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EXT_bgra" , &kGL_EXT_bgra); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EXT_paletted_texture" , &kGL_EXT_paletted_texture); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_WIN_swap_hint" , &kGL_WIN_swap_hint); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_WIN_draw_range_elements" , &kGL_WIN_draw_range_elements); assert(r>=0);
    
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_EXT" , &kGL_VERTEX_ARRAY_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_EXT" , &kGL_NORMAL_ARRAY_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_EXT" , &kGL_COLOR_ARRAY_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_EXT" , &kGL_INDEX_ARRAY_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_EXT" , &kGL_TEXTURE_COORD_ARRAY_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY_EXT" , &kGL_EDGE_FLAG_ARRAY_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_SIZE_EXT" , &kGL_VERTEX_ARRAY_SIZE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_TYPE_EXT" , &kGL_VERTEX_ARRAY_TYPE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_STRIDE_EXT" , &kGL_VERTEX_ARRAY_STRIDE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_COUNT_EXT" , &kGL_VERTEX_ARRAY_COUNT_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_TYPE_EXT" , &kGL_NORMAL_ARRAY_TYPE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_STRIDE_EXT" , &kGL_NORMAL_ARRAY_STRIDE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_COUNT_EXT" , &kGL_NORMAL_ARRAY_COUNT_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_SIZE_EXT" , &kGL_COLOR_ARRAY_SIZE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_TYPE_EXT" , &kGL_COLOR_ARRAY_TYPE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_STRIDE_EXT" , &kGL_COLOR_ARRAY_STRIDE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_COUNT_EXT" , &kGL_COLOR_ARRAY_COUNT_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_TYPE_EXT" , &kGL_INDEX_ARRAY_TYPE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_STRIDE_EXT" , &kGL_INDEX_ARRAY_STRIDE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_COUNT_EXT" , &kGL_INDEX_ARRAY_COUNT_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_SIZE_EXT" , &kGL_TEXTURE_COORD_ARRAY_SIZE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_TYPE_EXT" , &kGL_TEXTURE_COORD_ARRAY_TYPE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_STRIDE_EXT" , &kGL_TEXTURE_COORD_ARRAY_STRIDE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_COUNT_EXT" , &kGL_TEXTURE_COORD_ARRAY_COUNT_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY_STRIDE_EXT" , &kGL_EDGE_FLAG_ARRAY_STRIDE_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY_COUNT_EXT" , &kGL_EDGE_FLAG_ARRAY_COUNT_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_VERTEX_ARRAY_POINTER_EXT" , &kGL_VERTEX_ARRAY_POINTER_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_NORMAL_ARRAY_POINTER_EXT" , &kGL_NORMAL_ARRAY_POINTER_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_ARRAY_POINTER_EXT" , &kGL_COLOR_ARRAY_POINTER_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_INDEX_ARRAY_POINTER_EXT" , &kGL_INDEX_ARRAY_POINTER_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COORD_ARRAY_POINTER_EXT" , &kGL_TEXTURE_COORD_ARRAY_POINTER_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_EDGE_FLAG_ARRAY_POINTER_EXT" , &kGL_EDGE_FLAG_ARRAY_POINTER_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_DOUBLE_EXT" , &kGL_DOUBLE_EXT); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_BGR_EXT" , &kGL_BGR_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_BGRA_EXT" , &kGL_BGRA_EXT); assert(r>=0);


    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_FORMAT_EXT" , &kGL_COLOR_TABLE_FORMAT_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_WIDTH_EXT" , &kGL_COLOR_TABLE_WIDTH_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_RED_SIZE_EXT" , &kGL_COLOR_TABLE_RED_SIZE_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_GREEN_SIZE_EXT" , &kGL_COLOR_TABLE_GREEN_SIZE_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_BLUE_SIZE_EXT" , &kGL_COLOR_TABLE_BLUE_SIZE_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_ALPHA_SIZE_EXT" , &kGL_COLOR_TABLE_ALPHA_SIZE_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_LUMINANCE_SIZE_EXT" , &kGL_COLOR_TABLE_LUMINANCE_SIZE_EXT); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_TABLE_INTENSITY_SIZE_EXT" , &kGL_COLOR_TABLE_INTENSITY_SIZE_EXT); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX1_EXT" , &kGL_COLOR_INDEX1_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX2_EXT" , &kGL_COLOR_INDEX2_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX4_EXT" , &kGL_COLOR_INDEX4_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX8_EXT" , &kGL_COLOR_INDEX8_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX12_EXT" , &kGL_COLOR_INDEX12_EXT); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_COLOR_INDEX16_EXT" , &kGL_COLOR_INDEX16_EXT); assert(r>=0);

    // r=engine->RegisterGlobalProperty("const GLenum GL_MAX_ELEMENTS_VERTICES_WIN" , &kGL_MAX_ELEMENTS_VERTICES_WIN); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_MAX_ELEMENTS_INDICES_WIN" , &kGL_MAX_ELEMENTS_INDICES_WIN); assert(r>=0);

    // r=engine->RegisterGlobalProperty("const GLenum GL_PHONG_WIN" , &kGL_PHONG_WIN); assert(r>=0);
    // r=engine->RegisterGlobalProperty("const GLenum GL_PHONG_HINT_WIN" , &kGL_PHONG_HINT_WIN); assert(r>=0);

    // r=engine->RegisterGlobalProperty("const GLenum GL_FOG_SPECULAR_TEXTURE_WIN" , &kGL_FOG_SPECULAR_TEXTURE_WIN); assert(r>=0);

    r=engine->RegisterGlobalProperty("const GLenum GL_LOGIC_OP" , &kGL_LOGIC_OP); assert(r>=0);
    r=engine->RegisterGlobalProperty("const GLenum GL_TEXTURE_COMPONENTS" , &kGL_TEXTURE_COMPONENTS); assert(r>=0);


    r=engine->RegisterGlobalFunction("void glAccum (GLenum op, GLfloat value) ", asFUNCTION(glAccum), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glAlphaFunc (GLenum func, GLclampf ref) ", asFUNCTION(glAlphaFunc), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glArrayElement (GLint i) ", asFUNCTION(glArrayElement), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glBegin (GLenum mode) ", asFUNCTION(glBegin), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glBindTexture (GLenum target, GLuint texture) ", asFUNCTION(glBindTexture), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glBlendFunc (GLenum sfactor, GLenum dfactor) ", asFUNCTION(glBlendFunc), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCallList (GLuint list) ", asFUNCTION(glCallList), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glClear (GLbitfield mask) ", asFUNCTION(glClear), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glClearAccum (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) ", asFUNCTION(glClearAccum), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha) ", asFUNCTION(glClearColor), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glClearDepth (GLclampd depth) ", asFUNCTION(glClearDepth), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glClearIndex (GLfloat c) ", asFUNCTION(glClearIndex), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glClearStencil (GLint s) ", asFUNCTION(glClearStencil), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3b (GLbyte red, GLbyte green, GLbyte blue) ", asFUNCTION(glColor3b), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3d (GLdouble red, GLdouble green, GLdouble blue) ", asFUNCTION(glColor3d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3f (GLfloat red, GLfloat green, GLfloat blue) ", asFUNCTION(glColor3f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3i (GLint red, GLint green, GLint blue) ", asFUNCTION(glColor3i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3s (GLshort red, GLshort green, GLshort blue) ", asFUNCTION(glColor3s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3ub (GLubyte red, GLubyte green, GLubyte blue) ", asFUNCTION(glColor3ub), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3ui (GLuint red, GLuint green, GLuint blue) ", asFUNCTION(glColor3ui), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor3us (GLushort red, GLushort green, GLushort blue) ", asFUNCTION(glColor3us), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4b (GLbyte red, GLbyte green, GLbyte blue, GLbyte alpha) ", asFUNCTION(glColor4b), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4d (GLdouble red, GLdouble green, GLdouble blue, GLdouble alpha) ", asFUNCTION(glColor4d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) ", asFUNCTION(glColor4f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4i (GLint red, GLint green, GLint blue, GLint alpha) ", asFUNCTION(glColor4i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4s (GLshort red, GLshort green, GLshort blue, GLshort alpha) ", asFUNCTION(glColor4s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha) ", asFUNCTION(glColor4ub), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4ui (GLuint red, GLuint green, GLuint blue, GLuint alpha) ", asFUNCTION(glColor4ui), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColor4us (GLushort red, GLushort green, GLushort blue, GLushort alpha) ", asFUNCTION(glColor4us), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) ", asFUNCTION(glColorMask), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glColorMaterial (GLenum face, GLenum mode) ", asFUNCTION(glColorMaterial), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCopyPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum type) ", asFUNCTION(glCopyPixels), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCopyTexImage1D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLint border) ", asFUNCTION(glCopyTexImage1D), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCopyTexImage2D (GLenum target, GLint level, GLenum internalFormat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) ", asFUNCTION(glCopyTexImage2D), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCopyTexSubImage1D (GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) ", asFUNCTION(glCopyTexSubImage1D), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) ", asFUNCTION(glCopyTexSubImage2D), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glCullFace (GLenum mode) ", asFUNCTION(glCullFace), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDeleteLists (GLuint list, GLsizei range) ", asFUNCTION(glDeleteLists), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDepthFunc (GLenum func) ", asFUNCTION(glDepthFunc), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDepthMask (GLboolean flag) ", asFUNCTION(glDepthMask), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDepthRange (GLclampd zNear, GLclampd zFar) ", asFUNCTION(glDepthRange), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDisable (GLenum cap) ", asFUNCTION(glDisable), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDisableClientState (GLenum array) ", asFUNCTION(glDisableClientState), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDrawArrays (GLenum mode, GLint first, GLsizei count) ", asFUNCTION(glDrawArrays), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glDrawBuffer (GLenum mode) ", asFUNCTION(glDrawBuffer), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEdgeFlag (GLboolean flag) ", asFUNCTION(glEdgeFlag), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEnable (GLenum cap) ", asFUNCTION(glEnable), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEnableClientState (GLenum array) ", asFUNCTION(glEnableClientState), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEnd (void) ", asFUNCTION(glEnd), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEndList (void) ", asFUNCTION(glEndList), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalCoord1d (GLdouble u) ", asFUNCTION(glEvalCoord1d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalCoord1f (GLfloat u) ", asFUNCTION(glEvalCoord1f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalCoord2d (GLdouble u, GLdouble v) ", asFUNCTION(glEvalCoord2d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalCoord2f (GLfloat u, GLfloat v) ", asFUNCTION(glEvalCoord2f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalMesh1 (GLenum mode, GLint i1, GLint i2) ", asFUNCTION(glEvalMesh1), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalMesh2 (GLenum mode, GLint i1, GLint i2, GLint j1, GLint j2) ", asFUNCTION(glEvalMesh2), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalPoint1 (GLint i) ", asFUNCTION(glEvalPoint1), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glEvalPoint2 (GLint i, GLint j) ", asFUNCTION(glEvalPoint2), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glFinish (void) ", asFUNCTION(glFinish), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glFlush (void) ", asFUNCTION(glFlush), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glFogf (GLenum pname, GLfloat param) ", asFUNCTION(glFogf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glFogi (GLenum pname, GLint param) ", asFUNCTION(glFogi), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glFrontFace (GLenum mode) ", asFUNCTION(glFrontFace), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glFrustum (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) ", asFUNCTION(glFrustum), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("GLuint glGenLists (GLsizei range) ", asFUNCTION(glGenLists), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("GLenum glGetError (void) ", asFUNCTION(glGetError), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glHint (GLenum target, GLenum mode) ", asFUNCTION(glHint), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glIndexMask (GLuint mask) ", asFUNCTION(glIndexMask), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glIndexd (GLdouble c) ", asFUNCTION(glIndexd), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glIndexf (GLfloat c) ", asFUNCTION(glIndexf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glIndexi (GLint c) ", asFUNCTION(glIndexi), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glIndexs (GLshort c) ", asFUNCTION(glIndexs), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glIndexub (GLubyte c) ", asFUNCTION(glIndexub), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glInitNames (void) ", asFUNCTION(glInitNames), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("GLboolean glIsEnabled (GLenum cap) ", asFUNCTION(glIsEnabled), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("GLboolean glIsList (GLuint list) ", asFUNCTION(glIsList), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("GLboolean glIsTexture (GLuint texture) ", asFUNCTION(glIsTexture), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLightModelf (GLenum pname, GLfloat param) ", asFUNCTION(glLightModelf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLightModeli (GLenum pname, GLint param) ", asFUNCTION(glLightModeli), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLightf (GLenum light, GLenum pname, GLfloat param) ", asFUNCTION(glLightf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLighti (GLenum light, GLenum pname, GLint param) ", asFUNCTION(glLighti), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLineStipple (GLint factor, GLushort pattern) ", asFUNCTION(glLineStipple), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLineWidth (GLfloat width) ", asFUNCTION(glLineWidth), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glListBase (GLuint base) ", asFUNCTION(glListBase), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLoadIdentity (void) ", asFUNCTION(glLoadIdentity), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLoadName (GLuint name) ", asFUNCTION(glLoadName), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLogicOp (GLenum opcode) ", asFUNCTION(glLogicOp), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMapGrid1d (GLint un, GLdouble u1, GLdouble u2) ", asFUNCTION(glMapGrid1d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMapGrid1f (GLint un, GLfloat u1, GLfloat u2) ", asFUNCTION(glMapGrid1f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMapGrid2d (GLint un, GLdouble u1, GLdouble u2, GLint vn, GLdouble v1, GLdouble v2) ", asFUNCTION(glMapGrid2d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMapGrid2f (GLint un, GLfloat u1, GLfloat u2, GLint vn, GLfloat v1, GLfloat v2) ", asFUNCTION(glMapGrid2f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMaterialf (GLenum face, GLenum pname, GLfloat param) ", asFUNCTION(glMaterialf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMateriali (GLenum face, GLenum pname, GLint param) ", asFUNCTION(glMateriali), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMatrixMode (GLenum mode) ", asFUNCTION(glMatrixMode), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glNewList (GLuint list, GLenum mode) ", asFUNCTION(glNewList), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glNormal3b (GLbyte nx, GLbyte ny, GLbyte nz) ", asFUNCTION(glNormal3b), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glNormal3d (GLdouble nx, GLdouble ny, GLdouble nz) ", asFUNCTION(glNormal3d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz) ", asFUNCTION(glNormal3f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glNormal3i (GLint nx, GLint ny, GLint nz) ", asFUNCTION(glNormal3i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glNormal3s (GLshort nx, GLshort ny, GLshort nz) ", asFUNCTION(glNormal3s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glOrtho (GLdouble left, GLdouble right, GLdouble bottom, GLdouble top, GLdouble zNear, GLdouble zFar) ", asFUNCTION(glOrtho), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPassThrough (GLfloat token) ", asFUNCTION(glPassThrough), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPixelStoref (GLenum pname, GLfloat param) ", asFUNCTION(glPixelStoref), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPixelStorei (GLenum pname, GLint param) ", asFUNCTION(glPixelStorei), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPixelTransferf (GLenum pname, GLfloat param) ", asFUNCTION(glPixelTransferf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPixelTransferi (GLenum pname, GLint param) ", asFUNCTION(glPixelTransferi), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPixelZoom (GLfloat xfactor, GLfloat yfactor) ", asFUNCTION(glPixelZoom), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPointSize (GLfloat size) ", asFUNCTION(glPointSize), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPolygonMode (GLenum face, GLenum mode) ", asFUNCTION(glPolygonMode), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPolygonOffset (GLfloat factor, GLfloat units) ", asFUNCTION(glPolygonOffset), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPopAttrib (void) ", asFUNCTION(glPopAttrib), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPopClientAttrib (void) ", asFUNCTION(glPopClientAttrib), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPopMatrix (void) ", asFUNCTION(glPopMatrix), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPopName (void) ", asFUNCTION(glPopName), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPushAttrib (GLbitfield mask) ", asFUNCTION(glPushAttrib), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPushClientAttrib (GLbitfield mask) ", asFUNCTION(glPushClientAttrib), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPushMatrix (void) ", asFUNCTION(glPushMatrix), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glPushName (GLuint name) ", asFUNCTION(glPushName), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos2d (GLdouble x, GLdouble y) ", asFUNCTION(glRasterPos2d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos2f (GLfloat x, GLfloat y) ", asFUNCTION(glRasterPos2f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos2i (GLint x, GLint y) ", asFUNCTION(glRasterPos2i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos2s (GLshort x, GLshort y) ", asFUNCTION(glRasterPos2s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos3d (GLdouble x, GLdouble y, GLdouble z) ", asFUNCTION(glRasterPos3d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos3f (GLfloat x, GLfloat y, GLfloat z) ", asFUNCTION(glRasterPos3f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos3i (GLint x, GLint y, GLint z) ", asFUNCTION(glRasterPos3i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos3s (GLshort x, GLshort y, GLshort z) ", asFUNCTION(glRasterPos3s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w) ", asFUNCTION(glRasterPos4d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w) ", asFUNCTION(glRasterPos4f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos4i (GLint x, GLint y, GLint z, GLint w) ", asFUNCTION(glRasterPos4i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRasterPos4s (GLshort x, GLshort y, GLshort z, GLshort w) ", asFUNCTION(glRasterPos4s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glReadBuffer (GLenum mode) ", asFUNCTION(glReadBuffer), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRectd (GLdouble x1, GLdouble y1, GLdouble x2, GLdouble y2) ", asFUNCTION(glRectd), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRectf (GLfloat x1, GLfloat y1, GLfloat x2, GLfloat y2) ", asFUNCTION(glRectf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRecti (GLint x1, GLint y1, GLint x2, GLint y2) ", asFUNCTION(glRecti), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRects (GLshort x1, GLshort y1, GLshort x2, GLshort y2) ", asFUNCTION(glRects), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("GLint glRenderMode (GLenum mode) ", asFUNCTION(glRenderMode), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRotated (GLdouble angle, GLdouble x, GLdouble y, GLdouble z) ", asFUNCTION(glRotated), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z) ", asFUNCTION(glRotatef), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glScaled (GLdouble x, GLdouble y, GLdouble z) ", asFUNCTION(glScaled), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glScalef (GLfloat x, GLfloat y, GLfloat z) ", asFUNCTION(glScalef), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glScissor (GLint x, GLint y, GLsizei width, GLsizei height) ", asFUNCTION(glScissor), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glShadeModel (GLenum mode) ", asFUNCTION(glShadeModel), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glStencilFunc (GLenum func, GLint ref, GLuint mask) ", asFUNCTION(glStencilFunc), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glStencilMask (GLuint mask) ", asFUNCTION(glStencilMask), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass) ", asFUNCTION(glStencilOp), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord1d (GLdouble s) ", asFUNCTION(glTexCoord1d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord1f (GLfloat s) ", asFUNCTION(glTexCoord1f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord1i (GLint s) ", asFUNCTION(glTexCoord1i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord1s (GLshort s) ", asFUNCTION(glTexCoord1s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord2d (GLdouble s, GLdouble t) ", asFUNCTION(glTexCoord2d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord2f (GLfloat s, GLfloat t) ", asFUNCTION(glTexCoord2f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord2i (GLint s, GLint t) ", asFUNCTION(glTexCoord2i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord2s (GLshort s, GLshort t) ", asFUNCTION(glTexCoord2s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord3d (GLdouble s, GLdouble t, GLdouble r) ", asFUNCTION(glTexCoord3d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord3f (GLfloat s, GLfloat t, GLfloat r) ", asFUNCTION(glTexCoord3f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord3i (GLint s, GLint t, GLint r) ", asFUNCTION(glTexCoord3i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord3s (GLshort s, GLshort t, GLshort r) ", asFUNCTION(glTexCoord3s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord4d (GLdouble s, GLdouble t, GLdouble r, GLdouble q) ", asFUNCTION(glTexCoord4d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord4f (GLfloat s, GLfloat t, GLfloat r, GLfloat q) ", asFUNCTION(glTexCoord4f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord4i (GLint s, GLint t, GLint r, GLint q) ", asFUNCTION(glTexCoord4i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexCoord4s (GLshort s, GLshort t, GLshort r, GLshort q) ", asFUNCTION(glTexCoord4s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexEnvf (GLenum target, GLenum pname, GLfloat param) ", asFUNCTION(glTexEnvf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexEnvi (GLenum target, GLenum pname, GLint param) ", asFUNCTION(glTexEnvi), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexGend (GLenum coord, GLenum pname, GLdouble param) ", asFUNCTION(glTexGend), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexGenf (GLenum coord, GLenum pname, GLfloat param) ", asFUNCTION(glTexGenf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexGeni (GLenum coord, GLenum pname, GLint param) ", asFUNCTION(glTexGeni), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexParameterf (GLenum target, GLenum pname, GLfloat param) ", asFUNCTION(glTexParameterf), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTexParameteri (GLenum target, GLenum pname, GLint param) ", asFUNCTION(glTexParameteri), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTranslated (GLdouble x, GLdouble y, GLdouble z) ", asFUNCTION(glTranslated), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glTranslatef (GLfloat x, GLfloat y, GLfloat z) ", asFUNCTION(glTranslatef), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex2d (GLdouble x, GLdouble y) ", asFUNCTION(glVertex2d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex2f (GLfloat x, GLfloat y) ", asFUNCTION(glVertex2f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex2i (GLint x, GLint y) ", asFUNCTION(glVertex2i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex2s (GLshort x, GLshort y) ", asFUNCTION(glVertex2s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex3d (GLdouble x, GLdouble y, GLdouble z) ", asFUNCTION(glVertex3d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex3f (GLfloat x, GLfloat y, GLfloat z) ", asFUNCTION(glVertex3f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex3i (GLint x, GLint y, GLint z) ", asFUNCTION(glVertex3i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex3s (GLshort x, GLshort y, GLshort z) ", asFUNCTION(glVertex3s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex4d (GLdouble x, GLdouble y, GLdouble z, GLdouble w) ", asFUNCTION(glVertex4d), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex4f (GLfloat x, GLfloat y, GLfloat z, GLfloat w) ", asFUNCTION(glVertex4f), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex4i (GLint x, GLint y, GLint z, GLint w) ", asFUNCTION(glVertex4i), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glVertex4s (GLshort x, GLshort y, GLshort z, GLshort w) ", asFUNCTION(glVertex4s), asGLFunctionCall); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glViewport (GLint x, GLint y, GLsizei width, GLsizei height) ", asFUNCTION(glViewport), asGLFunctionCall); assert(r>=0);

    // vector functions
    r=engine->RegisterGlobalFunction("void glLightfv(GLenum light, GLenum pname, const array<GLfloat>& ) ", asFUNCTION(as_glLightfv), asCALL_CDECL); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glLightiv(GLenum light, GLenum pname, const array<GLint>& ) ", asFUNCTION(as_glLightiv), asCALL_CDECL); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMaterialfv(GLenum light, GLenum pname, const array<GLfloat>& ) ", asFUNCTION(as_glMaterialfv), asCALL_CDECL); assert(r>=0);
    r=engine->RegisterGlobalFunction("void glMaterialiv(GLenum light, GLenum pname, const array<GLint>& ) ", asFUNCTION(as_glMaterialiv), asCALL_CDECL); assert(r>=0);
}

void RegisterOpenGL_Generic(asIScriptEngine *engine)
{
    // not implemented
    assert(0);
}

#include <string>

void RegisterOpenGL(asIScriptEngine * engine)
{
    if (strstr(asGetLibraryOptions(), "AS_MAX_PORTABILITY"))
        RegisterOpenGL_Generic(engine);
    else
        RegisterOpenGL_Native(engine);
}
END_AS_NAMESPACE




